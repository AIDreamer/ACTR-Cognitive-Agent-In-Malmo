(#Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((ftype (function nil t) common-lisp-user::minimum-utility) proclaim)) #1=#P"C:/Users/Son Pham/Desktop/actr7/commands/procedural-cmds.lisp" 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((ftype (function (t) t) common-lisp-user::production-utility) proclaim)) #1# 19195) #Y(si::bytecodes nil nil (15 0 14 1 14 2 33 3 12 19 4 4 76 73 39 10 15 5 19 1 6 12 19 1 7 29) #A(t (8) ("PRODUCTIONS" *modules* :test string= member "ACT-R-support:productions" translate-logical-pathname common-lisp-user::compile-and-load)) #1# 19249) #Y(si::bytecodes nil nil (15 0 14 1 14 2 33 3 12 19 4 4 76 73 39 10 15 5 19 1 6 12 19 1 7 29) #A(t (8) ("PRODUCTION-PARSING" *modules* :test string= member "ACT-R-support:production-parsing-support" translate-logical-pathname common-lisp-user::compile-and-load)) #1# 19311) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 77 19 4 4 15 0 1 12 12 19 2 13 1 0 73 29) #2=#A(t (14) (common-lisp-user::all-productions ext::location (defun common-lisp-user::all-productions) (#1# . 19394) ext::annotate :lambda-list common-lisp-user::procedural common-lisp-user::get-module-fct common-lisp-user::prod common-lisp-user::production-name common-lisp-user::productions-list mapcar #Y(common-lisp-user::all-productions nil nil (26 15 6 19 1 7 45 8 10 0 73 39 13 33 9 12 13 0 19 1 10 12 19 2 11 43 1 29) #2# #1# 19394) si::fset)) #1# 19394) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 14 14 9 1 19 4 15 1 0 73 29) #3=#A(t (16) (common-lisp-user::pp ext::location (defmacro common-lisp-user::pp) (#1# . 19661) ext::annotate :lambda-list (&rest common-lisp-user::productions) #:g14666 #:g14665 #:g14667 common-lisp-user::productions common-lisp-user::pp-fct quote #Y(common-lisp-user::pp nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 15 11 15 12 10 0 6 2 6 2 73 29) #3# #1# 19661) t si::fset)) #1# 19661) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 33 12 19 2 34 1 0 73 29) #4=#A(t (35) (common-lisp-user::pp-fct ext::location (defun common-lisp-user::pp-fct) (#1# . 19722) ext::annotate :lambda-list (common-lisp-user::productions) common-lisp-user::productions common-lisp-user::procedural common-lisp-user::get-module-fct common-lisp-user::prod common-lisp-user::production-name common-lisp-user::productions-list mapcar common-lisp-user::p common-lisp-user::res si::%dolist-var common-lisp-user::p-name common-lisp-user::get-production-internal common-lisp-user::production common-lisp-user::print-production *error-output* #5="~&#|Warning~:[~*~;~@[ (in model ~a)~]~]: ~@? |#~%" common-lisp-user::current-mp-fct common-lisp-user::mp-models length > common-lisp-user::current-model "No production named ~S is defined" format finish-output reverse "No procedural module found" #Y(common-lisp-user::pp-fct nil nil (24 45 7 26 15 8 19 1 9 45 10 10 0 39 128 77 10 1 76 39 14 15 11 13 0 19 1 12 12 19 2 13 38 4 10 1 73 12 46 14 46 15 10 1 45 16 75 45 17 38 78 10 1 4 51 0 13 0 13 4 19 2 18 45 19 10 0 39 15 13 0 19 1 20 13 1 10 3 3 51 3 38 39 14 21 15 22 19 0 23 73 39 12 19 0 24 16 25 12 9 1 19 2 26 12 19 0 27 12 15 28 13 1 19 6 29 14 21 19 1 30 43 1 10 1 5 51 1 10 1 40 -80 43 2 10 0 16 31 43 2 38 40 14 21 15 22 19 0 23 73 39 12 19 0 24 16 25 12 9 1 19 2 26 12 19 0 27 12 15 32 19 5 29 12 14 21 19 1 30 22 73 43 1 29) #4# #1# 19722) si::fset)) #1# 19722) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 77 19 4 4 15 0 1 30 12 19 2 31 1 0 73 29) #6=#A(t (32) (common-lisp-user::clear-productions ext::location (defun common-lisp-user::clear-productions) (#1# . 20373) ext::annotate :lambda-list common-lisp-user::procedural common-lisp-user::get-module-fct common-lisp-user::prod *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > common-lisp-user::current-model "Clearing the productions is not recommended" format finish-output common-lisp-user::procedural-cond-style-usage-table clrhash common-lisp-user::procedural-req-style-usage-table common-lisp-user::procedural-mod-style-usage-table common-lisp-user::procedural-retrieval-cond-style-usage-table common-lisp-user::procedural-retrieval-req-style-usage-table common-lisp-user::productions-list si::%dolist-var common-lisp-user::p common-lisp-user::remove-production "No procedural module was found." #Y(common-lisp-user::clear-productions nil nil (26 15 6 19 1 7 45 8 10 0 39 111 14 9 15 10 19 0 11 73 39 12 19 0 12 16 13 12 9 1 19 2 14 12 19 0 15 12 15 16 19 5 17 14 9 19 1 18 13 0 19 1 19 16 20 13 0 19 1 21 16 20 13 0 19 1 22 16 20 13 0 19 1 23 16 20 13 0 19 1 24 16 20 13 0 19 1 25 45 26 75 45 27 38 18 10 1 4 51 0 13 0 13 2 19 2 28 10 1 5 51 1 10 1 40 -20 75 73 43 2 38 40 14 9 15 10 19 0 11 73 39 12 19 0 12 16 13 12 9 1 19 2 14 12 19 0 15 12 15 29 19 5 17 12 14 9 19 1 18 22 73 43 1 29) #6# #1# 20373) si::fset)) #1# 20373) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 14 14 9 1 19 4 15 1 0 73 29) #7=#A(t (16) (common-lisp-user::pbreak ext::location (defmacro common-lisp-user::pbreak) (#1# . 21022) ext::annotate :lambda-list (&rest common-lisp-user::productions) #:g14673 #:g14672 #:g14674 common-lisp-user::productions common-lisp-user::pbreak-fct quote #Y(common-lisp-user::pbreak nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 15 11 15 12 10 0 6 2 6 2 73 29) #7# #1# 21022) t si::fset)) #1# 21022) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 30 12 19 2 31 1 0 73 29) #8=#A(t (32) (common-lisp-user::pbreak-fct ext::location (defun common-lisp-user::pbreak-fct) (#1# . 21092) ext::annotate :lambda-list (common-lisp-user::productions) common-lisp-user::productions common-lisp-user::current-model si::%dolist-var common-lisp-user::production common-lisp-user::get-production common-lisp-user::it #:g14683 t #:g14684 si::structure-set *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > "~s is not the name of a production" format finish-output common-lisp-user::res common-lisp-user::all-productions common-lisp-user::production-break "There is no current model - pbreak cannot be used." #Y(common-lisp-user::pbreak-fct nil nil (24 45 7 26 19 0 8 39 159 10 0 45 9 75 45 10 38 87 10 1 4 51 0 13 0 19 1 11 45 12 10 0 39 26 10 0 45 13 11 14 45 15 13 1 15 10 9 12 13 0 19 4 16 43 1 43 1 38 39 14 17 15 18 19 0 19 73 39 12 19 0 20 16 21 12 9 1 19 2 22 12 19 0 8 12 15 23 13 1 19 6 24 14 17 19 1 25 43 1 10 1 5 51 1 10 1 40 -89 43 2 75 45 26 19 0 27 45 9 75 45 10 38 29 10 1 4 51 0 13 0 19 1 11 12 19 1 28 39 8 13 0 10 2 3 51 2 10 1 5 51 1 10 1 40 -31 75 51 0 10 2 73 43 2 43 1 38 40 14 17 15 18 19 0 19 73 39 12 19 0 20 16 21 12 9 1 19 2 22 12 19 0 8 12 15 29 19 5 24 12 14 17 19 1 25 22 73 29) #8# #1# 21092) si::fset)) #1# 21092) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 14 14 9 1 19 4 15 1 0 73 29) #9=#A(t (16) (common-lisp-user::punbreak ext::location (defmacro common-lisp-user::punbreak) (#1# . 21629) ext::annotate :lambda-list (&rest common-lisp-user::productions) #:g14688 #:g14687 #:g14689 common-lisp-user::productions common-lisp-user::punbreak-fct quote #Y(common-lisp-user::punbreak nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 15 11 15 12 10 0 6 2 6 2 73 29) #9# #1# 21629) t si::fset)) #1# 21629) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 29 12 19 2 30 1 0 73 29) #10=#A(t (31) (common-lisp-user::punbreak-fct ext::location (defun common-lisp-user::punbreak-fct) (#1# . 21703) ext::annotate :lambda-list (common-lisp-user::productions) common-lisp-user::productions common-lisp-user::current-model common-lisp-user::all-productions si::%dolist-var common-lisp-user::production common-lisp-user::get-production common-lisp-user::it #:g14698 #:g14699 si::structure-set *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > "~s is not the name of a production" format finish-output common-lisp-user::res common-lisp-user::production-break "There is no current model - punbreak cannot be used." #Y(common-lisp-user::punbreak-fct nil nil (24 45 7 26 19 0 8 39 168 10 0 76 39 6 19 0 9 38 3 10 0 45 10 75 45 11 38 86 10 1 4 51 0 13 0 19 1 12 45 13 10 0 39 25 10 0 45 14 75 45 15 13 1 15 11 9 12 13 0 19 4 16 43 1 43 1 38 39 14 17 15 18 19 0 19 73 39 12 19 0 20 16 21 12 9 1 19 2 22 12 19 0 8 12 15 23 13 1 19 6 24 14 17 19 1 25 43 1 10 1 5 51 1 10 1 40 -88 43 2 75 45 26 19 0 9 45 10 75 45 11 38 29 10 1 4 51 0 13 0 19 1 12 12 19 1 27 39 8 13 0 10 2 3 51 2 10 1 5 51 1 10 1 40 -31 75 51 0 10 2 73 43 2 43 1 38 40 14 17 15 18 19 0 19 73 39 12 19 0 20 16 21 12 9 1 19 2 22 12 19 0 8 12 15 28 19 5 24 12 14 17 19 1 25 22 73 29) #10# #1# 21703) si::fset)) #1# 21703) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 14 14 9 1 19 4 15 1 0 73 29) #11=#A(t (16) (common-lisp-user::pdisable ext::location (defmacro common-lisp-user::pdisable) (#1# . 22350) ext::annotate :lambda-list (&rest common-lisp-user::productions) #:g14703 #:g14702 #:g14704 common-lisp-user::productions common-lisp-user::pdisable-fct quote #Y(common-lisp-user::pdisable nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 15 11 15 12 10 0 6 2 6 2 73 29) #11# #1# 22350) t si::fset)) #1# 22350) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 30 12 19 2 31 1 0 73 29) #12=#A(t (32) (common-lisp-user::pdisable-fct ext::location (defun common-lisp-user::pdisable-fct) (#1# . 22428) ext::annotate :lambda-list (common-lisp-user::productions) common-lisp-user::productions common-lisp-user::current-model si::%dolist-var common-lisp-user::production common-lisp-user::get-production common-lisp-user::it #:g14713 t #:g14714 si::structure-set *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > "~s is not the name of a production" format finish-output common-lisp-user::res common-lisp-user::all-productions common-lisp-user::production-disabled "There is no current model - pdisable cannot be used." #Y(common-lisp-user::pdisable-fct nil nil (24 45 7 26 19 0 8 39 159 10 0 45 9 75 45 10 38 87 10 1 4 51 0 13 0 19 1 11 45 12 10 0 39 26 10 0 45 13 11 14 45 15 13 1 15 10 9 13 13 0 19 4 16 43 1 43 1 38 39 14 17 15 18 19 0 19 73 39 12 19 0 20 16 21 12 9 1 19 2 22 12 19 0 8 12 15 23 13 1 19 6 24 14 17 19 1 25 43 1 10 1 5 51 1 10 1 40 -89 43 2 75 45 26 19 0 27 45 9 75 45 10 38 29 10 1 4 51 0 13 0 19 1 11 12 19 1 28 39 8 13 0 10 2 3 51 2 10 1 5 51 1 10 1 40 -31 75 51 0 10 2 73 43 2 43 1 38 40 14 17 15 18 19 0 19 73 39 12 19 0 20 16 21 12 9 1 19 2 22 12 19 0 8 12 15 29 19 5 24 12 14 17 19 1 25 22 73 29) #12# #1# 22428) si::fset)) #1# 22428) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 14 14 9 1 19 4 15 1 0 73 29) #13=#A(t (16) (common-lisp-user::penable ext::location (defmacro common-lisp-user::penable) (#1# . 22975) ext::annotate :lambda-list (&rest common-lisp-user::productions) #:g14718 #:g14717 #:g14719 common-lisp-user::productions common-lisp-user::penable-fct quote #Y(common-lisp-user::penable nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 15 11 15 12 10 0 6 2 6 2 73 29) #13# #1# 22975) t si::fset)) #1# 22975) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 29 12 19 2 30 1 0 73 29) #14=#A(t (31) (common-lisp-user::penable-fct ext::location (defun common-lisp-user::penable-fct) (#1# . 23046) ext::annotate :lambda-list (common-lisp-user::productions) common-lisp-user::productions common-lisp-user::current-model common-lisp-user::all-productions si::%dolist-var common-lisp-user::production common-lisp-user::get-production common-lisp-user::it #:g14728 #:g14729 si::structure-set *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > "~s is not the name of a production" format finish-output common-lisp-user::res common-lisp-user::production-disabled "There is no current model - penable cannot be used." #Y(common-lisp-user::penable-fct nil nil (24 45 7 26 19 0 8 39 168 10 0 76 39 6 19 0 9 38 3 10 0 45 10 75 45 11 38 86 10 1 4 51 0 13 0 19 1 12 45 13 10 0 39 25 10 0 45 14 75 45 15 13 1 15 11 9 13 13 0 19 4 16 43 1 43 1 38 39 14 17 15 18 19 0 19 73 39 12 19 0 20 16 21 12 9 1 19 2 22 12 19 0 8 12 15 23 13 1 19 6 24 14 17 19 1 25 43 1 10 1 5 51 1 10 1 40 -88 43 2 75 45 26 19 0 9 45 10 75 45 11 38 29 10 1 4 51 0 13 0 19 1 12 12 19 1 27 39 8 13 0 10 2 3 51 2 10 1 5 51 1 10 1 40 -31 75 51 0 10 2 73 43 2 43 1 38 40 14 17 15 18 19 0 19 73 39 12 19 0 20 16 21 12 9 1 19 2 22 12 19 0 8 12 15 28 19 5 24 12 14 17 19 1 25 22 73 29) #14# #1# 23046) si::fset)) #1# 23046) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 14 14 9 1 19 4 15 1 0 73 29) #15=#A(t (16) (common-lisp-user::whynot ext::location (defmacro common-lisp-user::whynot) (#1# . 23697) ext::annotate :lambda-list (&rest common-lisp-user::productions) #:g14733 #:g14732 #:g14734 common-lisp-user::productions common-lisp-user::whynot-fct quote #Y(common-lisp-user::whynot nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 15 11 15 12 10 0 6 2 6 2 73 29) #15# #1# 23697) t si::fset)) #1# 23697) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 101 12 19 2 102 1 0 73 29) #16=#A(t (103) (common-lisp-user::whynot-fct ext::location (defun common-lisp-user::whynot-fct) (#1# . 23766) ext::annotate :lambda-list (common-lisp-user::productions) common-lisp-user::productions common-lisp-user::current-model common-lisp-user::procedural common-lisp-user::get-module-fct common-lisp-user::printing-module #:g14807 #:g14806 common-lisp-user::printing-module-suppress-cmds #:g14808 #:g14809 t #:g14810 (setf common-lisp-user::printing-module-suppress-cmds) common-lisp-user::pmatches-internal #:g14811 #:g14812 (setf common-lisp-user::printing-module-suppress-cmds) common-lisp-user::conflict-set common-lisp-user::all-productions si::%dolist-var common-lisp-user::production-name common-lisp-user::get-production common-lisp-user::production #:g14846 #:g14845 common-lisp-user::printing-module-c common-lisp-user::act-r-output-stream "~&~@?~%" "~%~s does not name a production." format common-lisp-user::production-disabled #:g14848 #:g14847 "~%Production ~s is disabled." member common-lisp-user::procedural-ppm common-lisp-user::production-partial-matched-slots #:g14850 #:g14849 "~%Production ~s partially matches the current state:" common-lisp-user::print-instantiation #:g14852 #:g14851 #:g14853 #:g14854 #:g14855 (setf common-lisp-user::printing-module-suppress-cmds) (:ut) common-lisp-user::sgp-fct #:g14856 #:g14857 (setf common-lisp-user::printing-module-suppress-cmds) common-lisp-user::ut numberp common-lisp-user::production-utility < #:g14859 #:g14858 "Utility was below the threshold the last time it was in the conflict set." #:g14861 #:g14860 "~%Production ~s matches:" #:g14863 #:g14862 #:g14864 #:g14865 #:g14866 (setf common-lisp-user::printing-module-suppress-cmds) (:ut) #:g14867 #:g14868 (setf common-lisp-user::printing-module-suppress-cmds) #:g14870 #:g14869 "Utility was below the threshold the last time it was in the conflict set." #:g14872 #:g14871 "~%Production ~s does NOT match." common-lisp-user::print-production #:g14874 #:g14873 "It fails because: " #:g14876 #:g14875 common-lisp-user::production-failure-condition common-lisp-user::failure-reason-string *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > "Whynot called with no current model." finish-output #Y(common-lisp-user::whynot-fct nil nil (24 45 7 26 19 0 8 39 895 15 9 19 1 10 45 9 15 11 19 1 10 47 1 12 45 13 10 1 39 59 13 0 19 1 14 45 15 10 1 45 16 11 17 45 18 13 0 13 1 33 19 18 2 43 1 43 1 64 7 13 3 19 1 20 65 10 1 45 21 10 1 45 22 13 0 13 1 33 23 18 2 43 1 43 1 66 43 1 43 2 45 24 10 2 76 39 6 19 0 25 38 3 10 2 45 26 75 45 27 38 780 10 1 4 51 0 13 0 19 1 28 45 29 10 0 76 39 57 15 11 19 1 10 47 1 30 45 31 10 1 39 18 13 0 19 1 14 76 39 10 13 0 19 1 32 12 19 1 33 39 20 13 0 19 1 32 12 19 1 33 12 15 34 15 35 13 3 19 4 36 43 2 38 700 13 0 19 1 37 39 57 15 11 19 1 10 47 1 38 45 39 10 1 39 18 13 0 19 1 14 76 39 10 13 0 19 1 32 12 19 1 33 39 20 13 0 19 1 32 12 19 1 33 12 15 34 15 40 13 3 19 4 36 43 2 38 637 13 1 13 3 19 2 41 39 455 13 4 19 1 42 39 6 13 0 19 1 43 39 221 15 11 19 1 10 47 1 44 45 45 10 1 39 18 13 0 19 1 14 76 39 10 13 0 19 1 32 12 19 1 33 39 20 13 0 19 1 32 12 19 1 33 12 15 34 15 46 13 3 19 4 36 43 2 13 0 19 1 47 15 11 19 1 10 47 1 48 45 49 10 1 39 59 13 0 19 1 14 45 50 10 1 45 51 11 17 45 52 13 0 13 1 33 53 18 2 43 1 43 1 64 7 15 54 19 1 55 65 10 1 45 56 10 1 45 57 13 0 13 1 33 58 18 2 43 1 43 1 66 43 1 43 2 4 45 59 10 0 16 60 39 21 13 2 19 1 61 16 60 39 12 13 2 19 1 61 12 13 0 19 2 62 39 53 15 11 19 1 10 47 1 63 45 64 10 1 39 18 13 0 19 1 14 76 39 10 13 0 19 1 32 12 19 1 33 39 18 13 0 19 1 32 12 19 1 33 12 15 34 15 65 19 3 36 43 2 43 1 38 219 15 11 19 1 10 47 1 66 45 67 10 1 39 18 13 0 19 1 14 76 39 10 13 0 19 1 32 12 19 1 33 39 20 13 0 19 1 32 12 19 1 33 12 15 34 15 68 13 3 19 4 36 43 2 13 0 19 1 47 15 11 19 1 10 47 1 69 45 70 10 1 39 59 13 0 19 1 14 45 71 10 1 45 72 11 17 45 73 13 0 13 1 33 74 18 2 43 1 43 1 64 7 15 75 19 1 55 65 10 1 45 76 10 1 45 77 13 0 13 1 33 78 18 2 43 1 43 1 66 43 1 43 2 4 45 59 10 0 16 60 39 21 13 2 19 1 61 16 60 39 12 13 2 19 1 61 12 13 0 19 2 62 39 53 15 11 19 1 10 47 1 79 45 80 10 1 39 18 13 0 19 1 14 76 39 10 13 0 19 1 32 12 19 1 33 39 18 13 0 19 1 32 12 19 1 33 12 15 34 15 81 19 3 36 43 2 43 1 38 174 15 11 19 1 10 47 1 82 45 83 10 1 39 18 13 0 19 1 14 76 39 10 13 0 19 1 32 12 19 1 33 39 20 13 0 19 1 32 12 19 1 33 12 15 34 15 84 13 3 19 4 36 43 2 13 0 19 1 85 15 11 19 1 10 47 1 86 45 87 10 1 39 18 13 0 19 1 14 76 39 10 13 0 19 1 32 12 19 1 33 39 18 13 0 19 1 32 12 19 1 33 12 15 34 15 88 19 3 36 43 2 15 11 19 1 10 47 1 89 45 90 10 1 39 18 13 0 19 1 14 76 39 10 13 0 19 1 32 12 19 1 33 39 28 13 0 19 1 32 12 19 1 33 12 15 34 13 2 19 1 91 12 13 2 19 2 92 12 19 3 36 43 2 43 1 10 1 5 51 1 10 1 40 -782 43 2 10 0 73 43 2 38 40 14 93 15 94 19 0 95 73 39 12 19 0 96 16 97 12 9 1 19 2 98 12 19 0 8 12 15 99 19 5 36 12 14 93 19 1 100 22 73 29) #16# #1# 23766) si::fset)) #1# 23766) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 19 2 14 1 0 73 29) #17=#A(t (15) (common-lisp-user::production-failure-reason ext::location (defun common-lisp-user::production-failure-reason) (#1# . 26338) ext::annotate :lambda-list (common-lisp-user::p-name) common-lisp-user::p-name common-lisp-user::get-production common-lisp-user::production common-lisp-user::production-failure-condition common-lisp-user::failure-reason-string "" #Y(common-lisp-user::production-failure-reason nil nil (24 45 7 26 13 0 19 1 8 45 9 10 0 39 6 13 0 19 1 10 39 14 13 0 19 1 10 12 13 0 19 2 11 38 4 1 12 73 43 1 29) #17# #1# 26338) si::fset)) #1# 26338) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 77 19 4 4 15 0 1 19 12 19 2 20 1 0 73 29) #18=#A(t (21) (common-lisp-user::pmatches ext::location (defun common-lisp-user::pmatches) (#1# . 26592) ext::annotate :lambda-list common-lisp-user::procedural common-lisp-user::get-module-fct common-lisp-user::pmatches-internal *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > common-lisp-user::current-model "No procedural module found" format finish-output #Y(common-lisp-user::pmatches nil nil (26 15 6 19 1 7 45 6 10 0 39 8 13 0 19 1 8 38 40 14 9 15 10 19 0 11 73 39 12 19 0 12 16 13 12 9 1 19 2 14 12 19 0 15 12 15 16 19 5 17 12 14 9 19 1 18 22 73 43 1 29) #18# #1# 26592) si::fset)) #1# 26592) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 67 12 19 2 68 1 0 73 29) #19=#A(t (69) (common-lisp-user::pmatches-internal ext::location (defun common-lisp-user::pmatches-internal) (#1# . 26770) ext::annotate :lambda-list (common-lisp-user::procedural) common-lisp-user::procedural #:g14913 common-lisp-user::procedural-buffer-lookup-size :initial-element :untested make-array #:g14914 si::structure-set #:g14915 common-lisp-user::largest-chunk-type-size #:g14916 common-lisp-user::procedural-last-cr-time numberp common-lisp-user::mp-time-ms = common-lisp-user::procedural-search-buffer-table clrhash make-hash-table common-lisp-user::saved-search-chunks common-lisp-user::conflict-set common-lisp-user::procedural-used-search-buffers si::%dolist-var common-lisp-user::b common-lisp-user::buffer-read common-lisp-user::it si::hash-set :clear common-lisp-user::procedural-productions common-lisp-user::production #:g14939 #:g14940 #:g14941 #:g14942 #:g14943 #:g14944 #:g14945 #:g14946 common-lisp-user::production-disabled common-lisp-user::production-constants common-lisp-user::test-constant-condition :report common-lisp-user::conflict-tests common-lisp-user::production-binds common-lisp-user::test-and-perform-bindings common-lisp-user::production-others common-lisp-user::test-other-condition common-lisp-user::production-searches common-lisp-user::test-search-buffers common-lisp-user::production-search-binds common-lisp-user::production-search-others #:g14948 nconc gethash common-lisp-user::val eq common-lisp-user::erase-buffer common-lisp-user::overwrite-buffer-chunk common-lisp-user::print-instantiation common-lisp-user::production-name mapcar #Y(common-lisp-user::pmatches-internal nil nil (24 45 7 26 10 0 45 8 13 1 19 1 9 6 1 12 14 10 14 11 19 3 12 45 13 13 1 15 7 9 18 13 0 19 4 14 43 1 43 1 10 0 45 15 13 1 19 1 9 12 19 0 16 6 2 12 14 10 14 11 19 3 12 45 17 13 1 15 7 9 20 13 0 19 4 14 43 1 43 1 13 0 19 1 18 16 19 39 14 13 0 19 1 18 12 19 0 20 12 19 2 21 76 39 8 13 0 19 1 22 16 23 77 19 0 24 12 46 25 46 26 13 2 19 1 27 45 28 75 45 29 38 44 10 1 4 51 0 13 0 19 1 30 45 31 10 0 39 12 13 1 13 4 13 0 19 3 32 38 10 13 1 13 4 14 33 19 3 32 43 1 10 1 5 51 1 10 1 40 -46 43 2 13 2 19 1 34 45 28 75 45 35 38 245 10 1 4 51 0 10 0 45 36 75 45 37 13 1 15 35 9 4 13 0 19 4 14 43 1 43 1 10 0 45 38 75 45 39 13 1 15 35 9 24 13 0 19 4 14 43 1 43 1 10 4 45 40 10 1 45 41 13 1 15 7 9 26 13 0 19 4 14 43 1 43 1 10 0 45 42 75 45 43 13 1 15 35 9 25 13 0 19 4 14 43 1 43 1 13 0 19 1 44 76 39 138 13 4 13 0 19 1 45 12 13 0 15 46 14 47 77 19 6 48 39 99 13 4 13 0 19 1 49 12 13 0 15 50 14 47 77 19 6 48 39 79 13 4 13 0 19 1 51 12 13 0 15 52 14 47 77 19 6 48 39 59 13 4 13 0 19 1 53 12 13 0 15 54 14 47 77 19 6 48 39 39 13 4 13 0 19 1 55 12 13 0 15 50 14 47 77 19 6 48 39 19 13 4 13 0 19 1 56 12 13 0 15 52 14 47 77 19 6 48 39 18 10 0 6 1 45 57 13 3 13 0 19 2 58 51 3 43 1 10 1 5 51 1 10 1 40 -247 43 2 13 2 19 1 27 45 28 75 45 29 38 48 10 1 4 51 0 13 0 13 3 19 2 59 45 60 10 0 39 23 13 0 11 33 17 61 39 8 13 1 19 1 62 38 8 13 1 13 0 19 2 63 43 1 10 1 5 51 1 10 1 40 -50 43 2 10 0 45 28 75 45 35 38 16 10 1 4 51 0 13 0 19 1 64 10 1 5 51 1 10 1 40 -18 43 2 33 65 12 13 0 19 2 66 43 2 29) #19# #1# 26770) si::fset)) #1# 26770) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 14 14 9 1 19 4 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #20=#A(t (19) (common-lisp-user::define-p ext::location (defmacro common-lisp-user::define-p) (#1# . 29401) ext::annotate :lambda-list (&rest common-lisp-user::definition) #:g14950 #:g14949 #:g14951 common-lisp-user::definition common-lisp-user::p-fct quote #Y(common-lisp-user::define-p nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 15 11 15 12 10 0 6 2 6 2 73 29) #20# #1# 29401) t si::fset function "Production definition." si::set-documentation)) #1# 29401) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 9 12 19 2 10 1 0 73 29) #21=#A(t (11) (common-lisp-user::define-p-fct ext::location (defun common-lisp-user::define-p-fct) (#1# . 29781) ext::annotate :lambda-list (common-lisp-user::definition) common-lisp-user::definition common-lisp-user::p-fct #Y(common-lisp-user::define-p-fct nil nil (24 45 7 26 13 0 19 1 8 29) #21# #1# 29781) si::fset)) #1# 29781) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 14 14 9 1 19 4 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #22=#A(t (19) (common-lisp-user::p ext::location (defmacro common-lisp-user::p) (#1# . 29837) ext::annotate :lambda-list (&rest common-lisp-user::definition) #:g14953 #:g14952 #:g14954 common-lisp-user::definition common-lisp-user::p-fct quote #Y(common-lisp-user::p nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 15 11 15 12 10 0 6 2 6 2 73 29) #22# #1# 29837) t si::fset function "Production definition." si::set-documentation)) #1# 29837) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 23 12 19 2 24 1 0 73 29) #23=#A(t (25) (common-lisp-user::p-fct ext::location (defun common-lisp-user::p-fct) (#1# . 29921) ext::annotate :lambda-list (common-lisp-user::definition) common-lisp-user::definition common-lisp-user::procedural common-lisp-user::get-module-fct common-lisp-user::prod common-lisp-user::procedural-p common-lisp-user::create-production *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > common-lisp-user::current-model "No procedural modulue found cannot create production." format finish-output #Y(common-lisp-user::p-fct nil nil (24 45 7 26 15 8 19 1 9 45 10 13 0 19 1 11 39 10 13 0 13 1 19 2 12 38 40 14 13 15 14 19 0 15 73 39 12 19 0 16 16 17 12 9 1 19 2 18 12 19 0 19 12 15 20 19 5 21 12 14 13 19 1 22 22 73 43 1 29) #23# #1# 29921) si::fset)) #1# 29921) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 22 12 19 2 23 1 0 73 29) #24=#A(t (24) (common-lisp-user::delete-production ext::location (defun common-lisp-user::delete-production) (#1# . 30146) ext::annotate :lambda-list (common-lisp-user::prod-name) common-lisp-user::prod-name common-lisp-user::procedural common-lisp-user::get-module-fct common-lisp-user::get-production-internal common-lisp-user::remove-production *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > common-lisp-user::current-model "No procedural module found.  Cannot delete production ~S." format finish-output #Y(common-lisp-user::delete-production nil nil (24 45 7 26 15 8 19 1 9 45 8 10 0 39 16 13 1 13 0 19 2 10 12 13 0 19 2 11 38 42 14 12 15 13 19 0 14 73 39 12 19 0 15 16 16 12 9 1 19 2 17 12 19 0 18 12 15 19 13 1 19 6 20 12 14 12 19 1 21 22 73 43 1 29) #24# #1# 30146) si::fset)) #1# 30146) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 16 12 14 17 9 3 19 4 18 1 0 73 29) #25=#A(t (19) (common-lisp-user::declare-buffer-usage ext::location (defmacro common-lisp-user::declare-buffer-usage) (#1# . 30431) ext::annotate :lambda-list (common-lisp-user::buffer type &rest common-lisp-user::slots) #:g14956 #:g14955 #:g14957 si::dm-too-few-arguments common-lisp-user::buffer type common-lisp-user::slots common-lisp-user::declare-buffer-usage-fct quote #Y(common-lisp-user::declare-buffer-usage nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 76 39 6 13 3 19 1 10 10 1 4 12 10 1 5 51 1 22 45 12 10 2 45 13 15 14 15 15 10 2 6 2 12 15 15 10 1 6 2 12 15 15 10 0 6 2 6 4 73 29) #25# #1# 30431) t si::fset)) #1# 30431) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 54 12 19 2 55 1 0 73 29) #26=#A(t (56) (common-lisp-user::declare-buffer-usage-fct ext::location (defun common-lisp-user::declare-buffer-usage-fct) (#1# . 30654) ext::annotate :lambda-list (common-lisp-user::buffer type &optional common-lisp-user::slots) common-lisp-user::buffer type common-lisp-user::slots common-lisp-user::procedural common-lisp-user::get-module-fct common-lisp-user::buffers find *error-output* #5# common-lisp-user::current-mp-fct common-lisp-user::mp-models length > common-lisp-user::current-model "Cannot declare usage for ~S because it does not name a buffer in the model." format finish-output common-lisp-user::chunk-type-p-fct "Cannot declare usage for buffer ~s because ~s does not name a chunk-type in the model." :all eq listp = common-lisp-user::x common-lisp-user::valid-chunk-type-slot #Y(nil nil nil (24 45 30 26 13 3 13 0 19 2 31 29) #26# #1# 30654) every "Cannot declare usage for buffer ~s because the slots (~{~s~^ ~}) are not valid for chunk-type ~s." #Y(nil nil nil (24 45 30 26 13 3 13 0 19 2 31 29) #26# #1# 30654) remove-if common-lisp-user::chunk-type-possible-slot-names-fct si::%dolist-var common-lisp-user::s #:g14983 #:g14980 common-lisp-user::procedural-cond-style-usage-table #:g14981 gethash #:g14982 si::hash-set #:g14991 #:g14988 common-lisp-user::procedural-init-chunk-slots #:g14989 #:g14990 t "No procedural module found.  Cannot declare buffer usage." #Y(common-lisp-user::declare-buffer-usage-fct nil nil (24 45 7 24 45 8 25 40 2 77 46 9 26 15 10 19 1 11 45 10 10 0 39 384 13 3 19 0 12 12 19 2 13 76 39 44 14 14 15 15 19 0 16 73 39 12 19 0 17 16 18 12 9 1 19 2 19 12 19 0 20 12 15 21 13 3 19 6 22 12 14 14 19 1 23 22 73 38 327 13 2 19 1 24 76 39 46 14 14 15 15 19 0 16 73 39 12 19 0 17 16 18 12 9 1 19 2 19 12 19 0 20 12 15 25 13 3 13 2 19 7 22 12 14 14 19 1 23 22 73 38 274 13 1 11 26 17 27 40 37 10 1 16 28 39 21 10 1 16 18 12 9 1 19 2 29 39 9 10 1 4 12 11 26 17 27 40 9 34 32 12 13 1 19 2 33 76 39 55 14 14 15 15 19 0 16 73 39 12 19 0 17 16 18 12 9 1 19 2 19 12 19 0 20 12 15 34 13 3 34 35 12 13 1 19 2 36 12 13 2 19 8 22 12 14 14 19 1 23 22 73 38 173 13 1 11 26 17 27 40 27 10 1 16 28 39 21 10 1 16 18 12 9 1 19 2 29 39 9 10 1 4 12 11 26 17 27 39 8 13 2 19 1 37 51 1 10 1 45 38 75 45 39 38 49 10 1 4 51 0 10 0 45 40 10 6 45 41 13 4 19 1 42 45 43 13 2 13 1 13 0 19 2 44 3 45 45 13 2 13 1 13 0 19 3 46 43 4 10 1 5 51 1 10 1 40 -51 43 2 10 1 45 38 75 45 39 38 49 10 1 4 51 0 10 0 45 47 10 6 45 48 13 4 19 1 49 45 50 13 2 13 1 13 0 19 2 44 3 45 51 13 2 13 1 13 0 19 3 46 43 4 10 1 5 51 1 10 1 40 -51 43 2 11 52 73 38 40 14 14 15 15 19 0 16 73 39 12 19 0 17 16 18 12 9 1 19 2 19 12 19 0 20 12 15 53 19 5 22 12 14 14 19 1 23 22 73 43 1 29) #26# #1# 30654) si::fset)) #1# 30654) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #27=#A(t (16) (common-lisp-user::production-firing-only ext::location (defun common-lisp-user::production-firing-only) (#1# . 32297) ext::annotate :lambda-list (common-lisp-user::event) common-lisp-user::event common-lisp-user::evt-action common-lisp-user::production-fired eq #Y(common-lisp-user::production-firing-only nil nil (24 45 7 26 13 0 19 1 8 12 1 9 17 10 29) #27# #1# 32297) si::fset function "Filter to show only production firing in the trace" si::set-documentation)) #1# 32297))
