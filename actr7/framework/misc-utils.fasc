(#Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((ftype (function (t) t) common-lisp-user::act-r-random) proclaim)) #1=#P"C:/Users/Son Pham/Desktop/actr7/framework/misc-utils.lisp" 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((ftype (function nil t) common-lisp-user::current-model) proclaim)) #1# 16606) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((ftype (function nil t) common-lisp-user::current-mp-fct) proclaim)) #1# 16654) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((ftype (function nil t) common-lisp-user::mp-models) proclaim)) #1# 16703) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ((ftype (function (t) t) common-lisp-user::get-module-fct) proclaim)) #1# 16747) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 15 12 14 16 9 2 19 4 17 1 0 73 29) #2=#A(t (18) (common-lisp-user::while ext::location (defmacro common-lisp-user::while) (#1# . 16797) ext::annotate :lambda-list (common-lisp-user::test &body common-lisp-user::body) #:g136 #:g135 #:g137 si::dm-too-few-arguments common-lisp-user::test common-lisp-user::body do not #Y(common-lisp-user::while nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 45 12 15 13 77 15 14 10 1 6 2 6 1 12 10 0 7 4 73 29) #2# #1# 16797) t si::fset)) #1# 16797) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 18 12 14 19 9 4 19 4 20 1 0 73 29) #3=#A(t (21) (common-lisp-user::aif ext::location (defmacro common-lisp-user::aif) (#1# . 17272) ext::annotate :lambda-list (common-lisp-user::test-form common-lisp-user::then-form &optional common-lisp-user::else-form) #:g139 #:g138 #:g140 si::dm-too-few-arguments common-lisp-user::test-form common-lisp-user::then-form common-lisp-user::else-form si::dm-too-many-arguments let common-lisp-user::it if #Y(common-lisp-user::aif nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 76 39 6 13 3 19 1 10 10 1 4 12 10 1 5 51 1 22 45 12 10 2 39 13 10 2 4 12 10 2 5 51 2 22 38 2 75 45 13 10 3 39 6 13 5 19 1 14 15 15 15 16 10 2 6 2 6 1 12 15 17 15 16 13 1 10 0 6 4 6 3 73 29) #3# #1# 17272) t si::fset)) #1# 17272) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 15 12 14 16 9 2 19 4 17 1 0 73 29) #4=#A(t (18) (common-lisp-user::awhen ext::location (defmacro common-lisp-user::awhen) (#1# . 17577) ext::annotate :lambda-list (common-lisp-user::test-form &body common-lisp-user::body) #:g142 #:g141 #:g143 si::dm-too-few-arguments common-lisp-user::test-form common-lisp-user::body common-lisp-user::aif progn #Y(common-lisp-user::awhen nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 45 12 15 13 13 1 15 14 10 0 7 2 6 3 73 29) #4# #1# 17577) t si::fset)) #1# 17577) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 40 12 14 41 9 2 19 4 42 1 0 73 29) #5=#A(t (43) (common-lisp-user::act-r_nconcf ext::location (defmacro common-lisp-user::act-r_nconcf) (#1# . 17659) ext::annotate :lambda-list (&environment si::env si::%reference &rest common-lisp-user::args) #:g144 si::env #:g145 si::dm-too-few-arguments si::%reference common-lisp-user::args get-setf-expansion si::getter si::setter si::stores si::vals si::vars si::v gensym #Y(nil nil nil (24 45 19 26 19 0 20 12 10 0 6 2 73 29) #5# #1# 17659) mapcar si::all-vars symbolp nconc car let* declare :read-only first subst si::let-list si::d listp the eq cadr append nreverse #Y(common-lisp-user::act-r_nconcf nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 45 12 13 1 13 3 19 2 13 47 4 14 47 3 15 47 2 16 47 1 17 45 18 34 21 12 10 5 7 1 12 19 2 22 45 23 10 5 16 24 39 51 15 25 13 5 33 26 12 13 0 19 2 22 7 3 12 10 3 4 12 15 27 13 0 15 28 14 29 33 30 12 13 0 19 2 22 7 2 6 2 12 10 4 6 4 12 19 3 31 38 151 13 1 13 2 77 46 32 46 19 46 33 38 29 10 0 5 12 10 1 5 12 10 0 4 12 10 1 4 6 2 12 10 2 3 12 53 2 53 1 53 0 10 0 76 39 -32 10 6 4 12 10 10 16 34 39 9 10 10 4 12 1 35 17 36 39 20 15 35 10 10 16 37 12 15 25 13 8 10 9 7 3 6 3 38 15 15 25 13 8 33 26 12 13 3 19 2 22 7 3 6 2 12 13 3 13 2 19 2 38 7 2 51 2 15 27 10 2 16 39 12 15 28 14 29 33 30 12 13 3 19 2 22 12 13 4 19 2 38 7 2 6 2 12 10 7 6 4 73 43 3 43 1 43 5 29) #5# #1# 17659) t si::fset)) #1# 17659) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 16 12 14 17 9 3 19 4 18 1 0 73 29) #6=#A(t (19) (common-lisp-user::push-last ext::location (defmacro common-lisp-user::push-last) (#1# . 17962) ext::annotate :lambda-list (common-lisp-user::item common-lisp-user::place) #:g147 #:g146 #:g148 si::dm-too-few-arguments common-lisp-user::item common-lisp-user::place si::dm-too-many-arguments common-lisp-user::act-r_nconcf list #Y(common-lisp-user::push-last nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 76 39 6 13 3 19 1 10 10 1 4 12 10 1 5 51 1 22 45 12 10 2 39 6 13 4 19 1 13 15 14 13 0 15 15 10 1 6 2 6 3 73 29) #6# #1# 17962) t si::fset)) #1# 17962) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 19 12 14 20 9 3 19 4 21 15 0 15 22 15 23 19 3 24 1 0 73 29) #7=#A(t (25) (common-lisp-user::expt-coerced ext::location (defmacro common-lisp-user::expt-coerced) (#1# . 18035) ext::annotate :lambda-list (common-lisp-user::base common-lisp-user::power) #:g150 #:g149 #:g151 si::dm-too-few-arguments common-lisp-user::base common-lisp-user::power si::dm-too-many-arguments 1.0 expt *read-default-float-format* typep coerce #Y(common-lisp-user::expt-coerced nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 76 39 6 13 3 19 1 10 10 1 4 12 10 1 5 51 1 22 45 12 10 2 39 6 13 4 19 1 13 15 14 1 14 17 15 12 14 16 19 2 17 39 12 15 15 13 1 10 0 6 3 73 38 17 15 18 15 15 13 1 10 0 6 3 12 11 16 6 3 73 29) #7# #1# 18035) t si::fset function "Computes expt and coerce to *read-default-float-format* if needed" si::set-documentation)) #1# 18035) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 19 12 14 20 9 2 19 4 21 15 0 15 22 15 23 19 3 24 1 0 73 29) #8=#A(t (25) (common-lisp-user::exp-coerced ext::location (defmacro common-lisp-user::exp-coerced) (#1# . 18818) ext::annotate :lambda-list (common-lisp-user::arg) #:g153 #:g152 #:g154 si::dm-too-few-arguments common-lisp-user::arg si::dm-too-many-arguments 1.0 expt *read-default-float-format* typep exp coerce #Y(common-lisp-user::exp-coerced nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 39 6 13 3 19 1 12 15 13 1 13 17 14 12 14 15 19 2 16 39 10 15 17 10 0 6 2 73 38 15 15 18 15 17 10 0 6 2 12 11 15 6 3 73 29) #8# #1# 18818) t si::fset function "Computes expt and coerce to *read-default-float-format* if needed" si::set-documentation)) #1# 18818) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 21 12 14 13 9 3 19 4 22 15 0 15 23 15 24 19 3 25 1 0 73 29) #9=#A(t (26) (common-lisp-user::log-coerced ext::location (defmacro common-lisp-user::log-coerced) (#1# . 19046) ext::annotate :lambda-list (common-lisp-user::arg &optional (common-lisp-user::base nil common-lisp-user::basep)) #:g156 #:g155 #:g157 si::dm-too-few-arguments common-lisp-user::arg common-lisp-user::base t common-lisp-user::basep si::dm-too-many-arguments 1.0 log *read-default-float-format* typep coerce #Y(common-lisp-user::log-coerced nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 39 6 10 1 4 38 2 75 45 12 10 2 39 8 10 2 5 51 2 11 13 45 14 10 3 39 6 13 5 19 1 15 15 16 19 1 17 12 14 18 19 2 19 39 25 10 0 39 12 15 17 13 2 10 1 6 3 73 38 8 15 17 10 2 6 2 73 38 37 10 0 39 19 15 20 15 17 13 2 10 1 6 3 12 11 18 6 3 73 38 15 15 20 15 17 10 2 6 2 12 11 18 6 3 73 29) #9# #1# 19046) si::fset function "Computes log and coerce to *read-default-float-format* if needed
   doesn't accept a base however" si::set-documentation)) #1# 19046) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 18 12 14 19 9 2 19 4 20 15 0 15 21 15 22 19 3 23 1 0 73 29) #10=#A(t (24) (common-lisp-user::sqrt-coerced ext::location (defmacro common-lisp-user::sqrt-coerced) (#1# . 19458) ext::annotate :lambda-list (common-lisp-user::arg) #:g159 #:g158 #:g160 si::dm-too-few-arguments common-lisp-user::arg si::dm-too-many-arguments 2.0 sqrt *read-default-float-format* typep coerce #Y(common-lisp-user::sqrt-coerced nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 39 6 13 3 19 1 12 1 13 16 14 12 14 15 19 2 16 39 10 15 14 10 0 6 2 73 38 15 15 17 15 14 10 0 6 2 12 11 15 6 3 73 29) #10# #1# 19458) t si::fset function "Computes sqrt and coerce to *read-default-float-format* if needed" si::set-documentation)) #1# 19458) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 18 12 14 19 9 2 19 4 20 15 0 15 21 15 22 19 3 23 1 0 73 29) #11=#A(t (24) (common-lisp-user::print-warning ext::location (defmacro common-lisp-user::print-warning) (#1# . 19685) ext::annotate :lambda-list (common-lisp-user::message &rest common-lisp-user::arguments) #:g162 #:g161 #:g163 si::dm-too-few-arguments common-lisp-user::message common-lisp-user::arguments common-lisp-user::finish-format *error-output* "~&#|Warning~:[~*~;~@[ (in model ~a)~]~]: ~@? |#~%" (and (common-lisp-user::current-mp-fct) (> (length (common-lisp-user::mp-models)) 1)) (common-lisp-user::current-model) #Y(common-lisp-user::print-warning nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 45 12 15 13 15 14 15 15 15 16 15 17 13 1 10 0 7 7 73 29) #11# #1# 19685) t si::fset function "Outputs a warning of message and arguments." si::set-documentation)) #1# 19685) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 19 2 14 15 0 15 15 15 16 19 3 17 1 0 73 29) #12=#A(t (18) (common-lisp-user::hash-table-keys ext::location (defun common-lisp-user::hash-table-keys) (#1# . 20429) ext::annotate :lambda-list (common-lisp-user::ht) common-lisp-user::ht common-lisp-user::keys common-lisp-user::key common-lisp-user::val #Y(nil nil nil (24 45 9 24 45 10 26 13 1 10 2 3 51 2 73 29) #12# #1# 20429) maphash #Y(common-lisp-user::hash-table-keys nil nil (24 45 7 26 75 45 8 34 11 12 10 1 17 12 10 0 73 43 1 29) #12# #1# 20429) si::fset function "Return the list of current keys in a hash-table" si::set-documentation)) #1# 20429) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #13=#A(t (17) (common-lisp-user::ms-round ext::location (defun common-lisp-user::ms-round) (#1# . 20666) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x * fround 1000.0 / #Y(common-lisp-user::ms-round nil nil (24 45 7 26 13 0 9 1000 19 2 8 12 19 1 9 12 15 10 19 2 11 29) #13# #1# 20666) si::fset function "Rounds a time to the nearest millisecond" si::set-documentation)) #1# 20666) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #14=#A(t (15) (common-lisp-user::seconds->ms ext::location (defun common-lisp-user::seconds->ms) (#1# . 20790) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x * round #Y(common-lisp-user::seconds->ms nil nil (24 45 7 26 13 0 9 1000 19 2 8 12 19 1 9 29) #14# #1# 20790) si::fset function "Rounds a time in seconds to an integer number of milliseconds" si::set-documentation)) #1# 20790) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #15=#A(t (15) (common-lisp-user::ms->seconds ext::location (defun common-lisp-user::ms->seconds) (#1# . 20902) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x 1000.0 / #Y(common-lisp-user::ms->seconds nil nil (24 45 7 26 13 0 15 8 19 2 9 29) #15# #1# 20902) si::fset function "Converts an integer number of milliseconds to a floating point number of seconds" si::set-documentation)) #1# 20902) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #16=#A(t (16) (common-lisp-user::fctornil ext::location (defun common-lisp-user::fctornil) (#1# . 21028) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x functionp symbolp fboundp #Y(common-lisp-user::fctornil nil nil (24 45 7 26 10 0 76 73 40 19 10 0 16 8 73 40 12 10 0 16 9 73 39 5 10 0 16 10 29) #16# #1# 21028) si::fset function "Checks if a symbol is a function, function name, or nil" si::set-documentation)) #1# 21028) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #17=#A(t (15) (common-lisp-user::tornil ext::location (defun common-lisp-user::tornil) (#1# . 21182) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x t eq #Y(common-lisp-user::tornil nil nil (24 45 7 26 13 0 11 8 17 9 73 40 6 13 0 75 17 9 29) #17# #1# 21182) si::fset function "Checks if a symbol is T or NIL" si::set-documentation)) #1# 21182) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #18=#A(t (15) (common-lisp-user::posnum ext::location (defun common-lisp-user::posnum) (#1# . 21264) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x numberp plusp #Y(common-lisp-user::posnum nil nil (24 45 7 26 10 0 16 8 73 39 5 10 0 16 9 29) #18# #1# 21264) si::fset function "Returns true only if <x> is a positive number" si::set-documentation)) #1# 21264) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #19=#A(t (15) (common-lisp-user::nonneg ext::location (defun common-lisp-user::nonneg) (#1# . 21364) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x numberp >= #Y(common-lisp-user::nonneg nil nil (24 45 7 26 10 0 16 8 73 39 8 13 0 9 0 19 2 9 29) #19# #1# 21364) si::fset function "Returns true only if <x> is a non-negative number" si::set-documentation)) #1# 21364) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 9 12 19 2 10 15 0 15 11 15 12 19 3 13 1 0 73 29) #20=#A(t (14) (common-lisp-user::numornil ext::location (defun common-lisp-user::numornil) (#1# . 21468) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x numberp #Y(common-lisp-user::numornil nil nil (24 45 7 26 10 0 76 73 40 5 10 0 16 8 29) #20# #1# 21468) si::fset function "Returns true only if <x> is a number or nil" si::set-documentation)) #1# 21468) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 9 12 19 2 10 15 0 15 11 15 12 19 3 13 1 0 73 29) #21=#A(t (14) (common-lisp-user::posnumornil ext::location (defun common-lisp-user::posnumornil) (#1# . 21567) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x common-lisp-user::posnum #Y(common-lisp-user::posnumornil nil nil (24 45 7 26 10 0 76 73 40 6 13 0 19 1 8 29) #21# #1# 21567) si::fset function "Returns true only if <x> is a positive number or nil" si::set-documentation)) #1# 21567) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 9 12 19 2 10 15 0 15 11 15 12 19 3 13 1 0 73 29) #22=#A(t (14) (common-lisp-user::nonnegornil ext::location (defun common-lisp-user::nonnegornil) (#1# . 21676) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x common-lisp-user::nonneg #Y(common-lisp-user::nonnegornil nil nil (24 45 7 26 10 0 76 73 40 6 13 0 19 1 8 29) #22# #1# 21676) si::fset function "Returns true only if <x> is a non-negative number or nil" si::set-documentation)) #1# 21676) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #23=#A(t (15) (common-lisp-user::numorbool ext::location (defun common-lisp-user::numorbool) (#1# . 21789) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x common-lisp-user::tornil numberp #Y(common-lisp-user::numorbool nil nil (24 45 7 26 13 0 19 1 8 73 40 5 10 0 16 9 29) #23# #1# 21789) si::fset function "Returns true only if <x> is a number, T or nil" si::set-documentation)) #1# 21789) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #24=#A(t (15) (common-lisp-user::posnumorbool ext::location (defun common-lisp-user::posnumorbool) (#1# . 21893) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x common-lisp-user::tornil common-lisp-user::posnum #Y(common-lisp-user::posnumorbool nil nil (24 45 7 26 13 0 19 1 8 73 40 6 13 0 19 1 9 29) #24# #1# 21893) si::fset function "Returns true only if <x> is a positive number, T or nil" si::set-documentation)) #1# 21893) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #25=#A(t (17) (common-lisp-user::safe> ext::location (defun common-lisp-user::safe>) (#1# . 22008) ext::annotate :lambda-list (common-lisp-user::val1 common-lisp-user::val2) common-lisp-user::val1 common-lisp-user::val2 numberp > t #Y(common-lisp-user::safe> nil nil (24 45 7 24 45 8 26 10 1 16 9 73 39 21 10 0 16 9 73 39 14 13 1 13 0 19 2 10 73 39 4 11 11 73 29) #25# #1# 22008) si::fset function "Return t if val1 and val2 are numbers and val1 > val2" si::set-documentation)) #1# 22008) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #26=#A(t (17) (common-lisp-user::safe>= ext::location (defun common-lisp-user::safe>=) (#1# . 22147) ext::annotate :lambda-list (common-lisp-user::val1 common-lisp-user::val2) common-lisp-user::val1 common-lisp-user::val2 numberp >= t #Y(common-lisp-user::safe>= nil nil (24 45 7 24 45 8 26 10 1 16 9 73 39 21 10 0 16 9 73 39 14 13 1 13 0 19 2 10 73 39 4 11 11 73 29) #26# #1# 22147) si::fset function "Return t if val1 and val2 are numbers and val1 >= val2" si::set-documentation)) #1# 22147) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #27=#A(t (17) (common-lisp-user::safe< ext::location (defun common-lisp-user::safe<) (#1# . 22289) ext::annotate :lambda-list (common-lisp-user::val1 common-lisp-user::val2) common-lisp-user::val1 common-lisp-user::val2 numberp < t #Y(common-lisp-user::safe< nil nil (24 45 7 24 45 8 26 10 1 16 9 73 39 21 10 0 16 9 73 39 14 13 1 13 0 19 2 10 73 39 4 11 11 73 29) #27# #1# 22289) si::fset function "Return t if val1 and val2 are numbers and val1 < val2" si::set-documentation)) #1# 22289) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 12 12 19 2 13 15 0 15 14 15 15 19 3 16 1 0 73 29) #28=#A(t (17) (common-lisp-user::safe<= ext::location (defun common-lisp-user::safe<=) (#1# . 22428) ext::annotate :lambda-list (common-lisp-user::val1 common-lisp-user::val2) common-lisp-user::val1 common-lisp-user::val2 numberp <= t #Y(common-lisp-user::safe<= nil nil (24 45 7 24 45 8 26 10 1 16 9 73 39 21 10 0 16 9 73 39 14 13 1 13 0 19 2 10 73 39 4 11 11 73 29) #28# #1# 22428) si::fset function "Return t if val1 and val2 are numbers and val1 <= val2" si::set-documentation)) #1# 22428) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 13 12 19 2 14 1 0 73 29) #29=#A(t (15) (common-lisp-user::splice-into-list ext::location (defun common-lisp-user::splice-into-list) (#1# . 22570) ext::annotate :lambda-list (common-lisp-user::lis position common-lisp-user::item) common-lisp-user::lis position common-lisp-user::item copy-list common-lisp-user::temp common-lisp-user::splice-into-list-des #Y(common-lisp-user::splice-into-list nil nil (24 45 7 24 45 8 24 45 9 26 10 2 16 10 45 11 13 0 13 2 13 1 19 3 12 43 1 29) #29# #1# 22570) si::fset)) #1# 22570) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 15 12 19 2 16 1 0 73 29) #30=#A(t (17) (common-lisp-user::splice-into-list-des ext::location (defun common-lisp-user::splice-into-list-des) (#1# . 22780) ext::annotate :lambda-list (common-lisp-user::lis position common-lisp-user::item) common-lisp-user::lis position common-lisp-user::item = listp subseq nthcdr nconc #Y(common-lisp-user::splice-into-list-des nil nil (24 45 7 24 45 8 24 45 9 26 13 1 9 0 19 2 10 39 11 13 0 10 2 3 51 2 73 38 56 10 0 16 11 39 25 13 2 9 0 13 1 19 3 12 12 13 0 13 1 10 2 17 13 12 19 3 14 38 26 13 2 9 0 13 1 19 3 12 12 10 0 6 1 12 13 1 10 2 17 13 12 19 3 14 29) #30# #1# 22780) si::fset)) #1# 22780) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 14 12 19 2 15 1 0 73 29) #31=#A(t (16) (common-lisp-user::splice-into-position-des ext::location (defun common-lisp-user::splice-into-position-des) (#1# . 23137) ext::annotate :lambda-list (common-lisp-user::lis position common-lisp-user::item) common-lisp-user::lis position common-lisp-user::item = subseq nthcdr nconc #Y(common-lisp-user::splice-into-position-des nil nil (24 45 7 24 45 8 24 45 9 26 13 1 9 0 19 2 10 39 11 13 0 10 2 3 51 2 73 38 26 13 2 9 0 13 1 19 3 11 12 10 0 6 1 12 13 1 10 2 17 12 12 19 3 13 29) #31# #1# 23137) si::fset)) #1# 23137) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 9 12 19 2 10 15 0 15 11 15 12 19 3 13 1 0 73 29) #32=#A(t (14) (common-lisp-user::mklist ext::location (defun common-lisp-user::mklist) (#1# . 23396) ext::annotate :lambda-list (common-lisp-user::obj) common-lisp-user::obj listp #Y(common-lisp-user::mklist nil nil (24 45 7 26 10 0 16 8 39 6 10 0 73 38 6 10 0 6 1 73 29) #32# #1# 23396) si::fset function "If the object is not a list, return a list containing the object" si::set-documentation)) #1# 23396) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 24 12 14 25 9 2 19 4 26 1 0 73 29) #33=#A(t (27) (common-lisp-user::model-output ext::location (defmacro common-lisp-user::model-output) (#1# . 23619) ext::annotate :lambda-list (common-lisp-user::control-string &rest common-lisp-user::args) #:g171 #:g170 #:g172 si::dm-too-few-arguments common-lisp-user::control-string common-lisp-user::args gensym common-lisp-user::present common-lisp-user::module multiple-value-bind (common-lisp-user::get-module-fct 'common-lisp-user::printing-module) when and common-lisp-user::act-r-output-stream common-lisp-user::printing-module-v format "~&~@?~%" #Y(common-lisp-user::model-output nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 45 12 19 0 13 12 19 0 13 12 46 14 46 15 15 16 13 0 10 1 6 2 12 15 17 15 18 15 19 13 1 15 20 15 21 10 0 6 2 6 2 6 3 12 15 22 15 20 15 21 10 0 6 2 6 2 12 15 23 13 3 10 2 7 5 6 3 6 4 73 43 2 29) #33# #1# 23619) t si::fset)) #1# 23619) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 26 12 14 27 9 2 19 4 28 1 0 73 29) #34=#A(t (29) (common-lisp-user::command-output ext::location (defmacro common-lisp-user::command-output) (#1# . 24191) ext::annotate :lambda-list (common-lisp-user::control-string &rest common-lisp-user::args) #:g174 #:g173 #:g175 si::dm-too-few-arguments common-lisp-user::control-string common-lisp-user::args gensym common-lisp-user::present common-lisp-user::module multiple-value-bind (common-lisp-user::get-module-fct 'common-lisp-user::printing-module) when and not common-lisp-user::printing-module-suppress-cmds common-lisp-user::act-r-output-stream common-lisp-user::printing-module-c format "~&~@?~%" #Y(common-lisp-user::command-output nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 45 12 19 0 13 12 19 0 13 12 46 14 46 15 15 16 13 0 10 1 6 2 12 15 17 15 18 15 19 13 1 15 20 15 21 10 0 6 2 6 2 12 15 22 15 23 10 0 6 2 6 2 6 4 12 15 24 15 22 15 23 10 0 6 2 6 2 12 15 25 13 3 10 2 7 5 6 3 6 4 73 43 2 29) #34# #1# 24191) t si::fset)) #1# 24191) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 24 12 14 21 9 1 19 4 25 15 0 15 26 15 27 19 3 28 1 0 73 29) #35=#A(t (29) (common-lisp-user::no-output ext::location (defmacro common-lisp-user::no-output) (#1# . 24667) ext::annotate :lambda-list (&rest common-lisp-user::commands) #:g177 #:g176 #:g178 common-lisp-user::commands gensym common-lisp-user::current common-lisp-user::present common-lisp-user::module multiple-value-bind (common-lisp-user::get-module-fct 'common-lisp-user::printing-module) when let common-lisp-user::printing-module-suppress-cmds setf t unwind-protect progn #Y(common-lisp-user::no-output nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 19 0 11 12 19 0 11 12 19 0 11 12 46 12 46 13 46 14 15 15 13 0 10 1 6 2 12 15 16 15 17 13 1 15 18 13 2 15 19 10 0 6 2 6 2 6 1 12 15 20 15 19 10 0 6 2 12 1 21 6 3 12 15 22 15 23 10 3 7 2 12 15 20 15 19 10 0 6 2 12 10 2 6 3 6 3 6 4 6 3 6 4 73 43 3 29) #35# #1# 24667) si::fset function "Suppress command output while evaluating ACT-R commands" si::set-documentation)) #1# 24667) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 27 12 14 28 9 1 19 4 29 15 0 15 30 15 31 19 3 32 1 0 73 29) #36=#A(t (33) (common-lisp-user::suppress-warnings ext::location (defmacro common-lisp-user::suppress-warnings) (#1# . 25248) ext::annotate :lambda-list (&rest common-lisp-user::commands) #:g180 #:g179 #:g181 common-lisp-user::commands gensym common-lisp-user::current common-lisp-user::present common-lisp-user::module if (common-lisp-user::current-model) multiple-value-bind (common-lisp-user::get-module-fct 'common-lisp-user::printing-module) when let (*error-output* (make-broadcast-stream)) common-lisp-user::printing-module-model-warnings setf unwind-protect progn ((*error-output* (make-broadcast-stream))) #Y(common-lisp-user::suppress-warnings nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 19 0 11 12 19 0 11 12 19 0 11 12 46 12 46 13 46 14 15 15 15 16 15 17 13 0 10 1 6 2 12 15 18 15 19 13 1 15 20 15 21 13 2 15 22 10 0 6 2 6 2 6 2 12 15 23 15 22 10 0 6 2 12 75 6 3 12 15 24 15 25 10 3 7 2 12 15 23 15 22 10 0 6 2 12 10 2 6 3 6 3 6 4 6 3 6 4 12 15 20 15 26 10 3 7 3 6 4 73 43 3 29) #36# #1# 25248) t si::fset function "Suppress all ACT-R warnings while evaluating ACT-R commands" si::set-documentation)) #1# 25248) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 32 12 14 33 9 1 19 4 34 15 0 15 35 15 36 19 3 37 1 0 73 29) #37=#A(t (38) (common-lisp-user::capture-model-output ext::location (defmacro common-lisp-user::capture-model-output) (#1# . 26018) ext::annotate :lambda-list (&rest common-lisp-user::commands) #:g183 #:g182 #:g184 common-lisp-user::commands gensym common-lisp-user::out-stream common-lisp-user::current-c common-lisp-user::current-v common-lisp-user::present common-lisp-user::module multiple-value-bind (common-lisp-user::get-module-fct 'common-lisp-user::printing-module) when let (make-string-output-stream) common-lisp-user::printing-module-v common-lisp-user::printing-module-c setf common-lisp-user::make-act-r-output :stream unwind-protect progn prog1 get-output-stream-string close #Y(common-lisp-user::capture-model-output nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 45 10 19 0 11 12 19 0 11 12 19 0 11 12 19 0 11 12 19 0 11 12 46 12 46 13 46 14 46 15 46 16 15 17 13 0 10 1 6 2 12 15 18 15 19 13 1 15 20 13 4 1 21 6 2 12 13 2 15 22 10 0 6 2 6 2 12 13 3 15 23 10 0 6 2 6 2 6 3 12 15 24 15 22 10 0 6 2 12 15 25 14 26 10 4 6 3 6 3 12 15 24 15 23 10 0 6 2 12 15 25 14 26 10 4 6 3 6 3 12 15 27 15 28 10 5 7 2 12 15 28 15 24 15 22 10 0 6 2 12 10 2 6 3 12 15 24 15 23 10 0 6 2 12 10 3 6 3 6 3 6 3 12 15 29 15 30 10 4 6 2 12 15 31 10 4 6 2 6 3 6 6 6 3 6 4 73 43 5 29) #37# #1# 26018) t si::fset function "Return the string of all model output from commands" si::set-documentation)) #1# 26018) #Y(si::bytecodes nil nil (1 0 16 1 75 52 0 15 0 15 2 15 3 15 4 19 4 5 1 0 73 29) #A(t (6) (common-lisp-user::*one-stream-hack* si::*make-special ext::location (defparameter common-lisp-user::*one-stream-hack*) (#1# . 27076) ext::annotate)) #1# 27076) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 44 12 14 31 9 2 19 4 45 1 0 73 29) #38=#A(t (46) (common-lisp-user::model-warning ext::location (defmacro common-lisp-user::model-warning) (#1# . 27486) ext::annotate :lambda-list (common-lisp-user::control-string &rest common-lisp-user::args) #:g186 #:g185 #:g187 si::dm-too-few-arguments common-lisp-user::control-string common-lisp-user::args gensym stream common-lisp-user::present common-lisp-user::module multiple-value-bind (common-lisp-user::get-module-fct 'common-lisp-user::printing-module) when and common-lisp-user::act-r-output-stream common-lisp-user::printing-module-v let cond null common-lisp-user::printing-module-model-warnings or eq *error-output* common-lisp-user::*one-stream-hack* t (eql *error-output* *standard-output*) common-lisp-user::finish-format "~&#|Warning~:[~*~; (in model ~a)~]: ~@? |#~%" (> (length (common-lisp-user::mp-models)) 1) (common-lisp-user::current-model) "~&#|Warning~:[~*~; (in model ~a)~]: ~@? |#~%" (> (length (common-lisp-user::mp-models)) 1) (common-lisp-user::current-model) format "~&#|Warning~:[~*~; (in model ~a)~]: ~@? |#~%" (> (length (common-lisp-user::mp-models)) 1) (common-lisp-user::current-model) #Y(common-lisp-user::model-warning nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 45 12 19 0 13 12 19 0 13 12 19 0 13 12 46 14 46 15 46 16 15 17 13 0 10 1 6 2 12 15 18 15 19 15 20 13 1 15 21 15 22 10 0 6 2 6 2 6 3 12 15 23 13 2 15 21 15 22 10 0 6 2 6 2 6 2 6 1 12 15 24 15 25 15 26 10 0 6 2 6 2 6 1 12 15 27 15 25 10 2 6 2 12 15 28 13 2 1 29 6 3 12 15 30 15 20 15 28 13 2 1 31 6 3 12 1 32 6 3 6 5 12 15 33 15 29 15 34 15 35 15 36 13 4 10 3 7 7 6 2 12 15 31 15 33 15 29 15 37 15 38 15 39 13 4 10 3 7 7 12 15 40 13 2 15 41 15 42 15 43 13 4 10 3 7 7 6 3 6 4 12 75 6 4 6 3 6 4 73 43 3 29) #38# #1# 27486) si::fset)) #1# 27486) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 50 12 14 37 9 3 19 4 51 1 0 73 29) #39=#A(t (52) (common-lisp-user::one-time-model-warning ext::location (defmacro common-lisp-user::one-time-model-warning) (#1# . 28715) ext::annotate :lambda-list (common-lisp-user::tag common-lisp-user::control-string &rest common-lisp-user::args) #:g189 #:g188 #:g190 si::dm-too-few-arguments common-lisp-user::tag common-lisp-user::control-string common-lisp-user::args gensym stream common-lisp-user::present common-lisp-user::module multiple-value-bind (common-lisp-user::get-module-fct 'common-lisp-user::printing-module) when and common-lisp-user::act-r-output-stream common-lisp-user::printing-module-v let unless find common-lisp-user::printing-module-one-time-tags (:test 'equal) push cond null common-lisp-user::printing-module-model-warnings or eq *error-output* common-lisp-user::*one-stream-hack* t (eql *error-output* *standard-output*) common-lisp-user::finish-format #40="~&#|Warning~:[~*~; (in model ~a)~]: ~@? |#~%" (> (length (common-lisp-user::mp-models)) 1) (common-lisp-user::current-model) #41="~&#|Warning~:[~*~; (in model ~a)~]: ~@? |#~%" (> (length (common-lisp-user::mp-models)) 1) (common-lisp-user::current-model) format #42="~&#|Warning~:[~*~; (in model ~a)~]: ~@? |#~%" (> (length (common-lisp-user::mp-models)) 1) (common-lisp-user::current-model) #Y(common-lisp-user::one-time-model-warning nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 76 39 6 13 3 19 1 10 10 1 4 12 10 1 5 51 1 22 45 12 10 2 45 13 19 0 14 12 19 0 14 12 19 0 14 12 46 15 46 16 46 17 15 18 13 0 10 1 6 2 12 15 19 15 20 15 21 13 1 15 22 15 23 10 0 6 2 6 2 6 3 12 15 24 13 2 15 22 15 23 10 0 6 2 6 2 6 2 6 1 12 15 25 15 26 13 5 15 27 10 0 6 2 12 1 28 7 4 12 15 29 13 5 15 27 10 0 6 2 6 3 12 15 30 15 31 15 32 10 0 6 2 6 2 6 1 12 15 33 15 31 10 2 6 2 12 15 34 13 2 1 35 6 3 12 15 36 15 21 15 34 13 2 1 37 6 3 12 1 38 6 3 6 5 12 15 39 15 35 15 40 15 41 15 42 13 4 10 3 7 7 6 2 12 15 37 15 39 15 35 15 43 15 44 15 45 13 4 10 3 7 7 12 15 46 13 2 15 47 15 48 15 49 13 4 10 3 7 7 6 3 6 4 12 75 6 5 6 3 6 3 6 4 73 43 3 29) #39# #1# 28715) si::fset)) #1# 28715) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 46 12 14 47 9 2 19 4 48 1 0 73 29) #43=#A(t (49) (common-lisp-user::meta-p-output ext::location (defmacro common-lisp-user::meta-p-output) (#1# . 30123) ext::annotate :lambda-list (common-lisp-user::control-string &rest common-lisp-user::args) #:g192 #:g191 #:g193 si::dm-too-few-arguments common-lisp-user::control-string common-lisp-user::args gensym common-lisp-user::previous-model common-lisp-user::m common-lisp-user::used-streams common-lisp-user::model stream common-lisp-user::present common-lisp-user::module if (common-lisp-user::current-mp) common-lisp-user::cannot-define-model let (common-lisp-user::current-model-struct) unwind-protect dolist (common-lisp-user::meta-p-model-order (common-lisp-user::current-mp)) gethash (common-lisp-user::meta-p-models (common-lisp-user::current-mp)) setf (common-lisp-user::meta-p-current-model (common-lisp-user::current-mp)) multiple-value-bind (common-lisp-user::get-module-fct 'common-lisp-user::printing-module) when and common-lisp-user::act-r-output-stream common-lisp-user::printing-module-v unless member push format "~&~@?~%" (common-lisp-user::meta-p-current-model (common-lisp-user::current-mp)) (common-lisp-user::print-warning "No current meta-process in call to meta-p-output") #Y(common-lisp-user::meta-p-output nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 45 12 19 0 13 12 19 0 13 12 19 0 13 12 19 0 13 12 19 0 13 12 19 0 13 12 19 0 13 12 46 14 46 15 46 16 46 17 46 18 46 19 46 20 15 21 15 22 15 23 15 24 13 4 75 6 2 12 13 6 1 25 6 2 6 2 12 15 26 15 27 13 5 1 28 6 2 12 15 24 13 3 15 29 13 5 1 30 6 3 6 2 6 1 12 15 31 15 32 10 3 6 3 12 15 33 13 0 10 1 6 2 12 15 34 15 35 15 36 13 1 15 37 15 38 10 0 6 2 6 2 6 3 12 15 24 13 2 15 37 15 38 10 0 6 2 6 2 6 2 6 1 12 15 39 15 40 13 2 10 4 6 3 12 15 41 13 2 10 4 6 3 12 15 42 13 2 15 43 13 8 10 7 7 5 6 4 6 3 6 3 6 4 6 4 6 3 12 15 31 15 44 10 6 6 3 6 3 6 3 12 75 6 3 12 1 45 6 4 73 43 7 29) #43# #1# 30123) t si::fset)) #1# 30123) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #44=#A(t (16) (common-lisp-user::rad->deg ext::location (defun common-lisp-user::rad->deg) (#1# . 31479) ext::annotate :lambda-list (common-lisp-user::r) common-lisp-user::r pi / * #Y(common-lisp-user::rad->deg nil nil (24 45 7 26 13 0 9 180 14 8 19 2 9 12 19 2 10 29) #44# #1# 31479) si::fset function "Converts radians into degrees." si::set-documentation)) #1# 31479) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #45=#A(t (16) (common-lisp-user::deg->rad ext::location (defun common-lisp-user::deg->rad) (#1# . 31578) ext::annotate :lambda-list (common-lisp-user::d) common-lisp-user::d pi / * #Y(common-lisp-user::deg->rad nil nil (24 45 7 26 14 8 9 180 19 2 9 12 13 0 19 2 10 29) #45# #1# 31578) si::fset function "Converts degrees into radians." si::set-documentation)) #1# 31578) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 14 12 14 15 9 2 19 4 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #46=#A(t (20) (common-lisp-user::px ext::location (defmacro common-lisp-user::px) (#1# . 31678) ext::annotate :lambda-list (common-lisp-user::vpt) #:g195 #:g194 #:g196 si::dm-too-few-arguments common-lisp-user::vpt si::dm-too-many-arguments svref #Y(common-lisp-user::px nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 39 6 13 3 19 1 12 15 13 13 0 8 0 6 3 73 29) #46# #1# 31678) t si::fset function "X coordinate of an XY vector." si::set-documentation)) #1# 31678) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 14 12 14 15 9 2 19 4 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #47=#A(t (20) (common-lisp-user::py ext::location (defmacro common-lisp-user::py) (#1# . 31751) ext::annotate :lambda-list (common-lisp-user::vpt) #:g198 #:g197 #:g199 si::dm-too-few-arguments common-lisp-user::vpt si::dm-too-many-arguments svref #Y(common-lisp-user::py nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 39 6 13 3 19 1 12 15 13 13 0 8 1 6 3 73 29) #47# #1# 31751) t si::fset function "Y coordinate of an XY vector." si::set-documentation)) #1# 31751) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 14 12 14 15 9 2 19 4 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #48=#A(t (20) (common-lisp-user::pz ext::location (defmacro common-lisp-user::pz) (#1# . 31824) ext::annotate :lambda-list (common-lisp-user::vpt) #:g201 #:g200 #:g202 si::dm-too-few-arguments common-lisp-user::vpt si::dm-too-many-arguments svref #Y(common-lisp-user::pz nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 39 6 13 3 19 1 12 15 13 13 0 8 2 6 3 73 29) #48# #1# 31824) t si::fset function "Z coordinate of an XYZ vector." si::set-documentation)) #1# 31824) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 14 12 14 15 9 2 19 4 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #49=#A(t (20) (common-lisp-user::vr ext::location (defmacro common-lisp-user::vr) (#1# . 31898) ext::annotate :lambda-list (common-lisp-user::vrt) #:g204 #:g203 #:g205 si::dm-too-few-arguments common-lisp-user::vrt si::dm-too-many-arguments svref #Y(common-lisp-user::vr nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 39 6 13 3 19 1 12 15 13 13 0 8 0 6 3 73 29) #49# #1# 31898) t si::fset function "R component of an r-theta vector." si::set-documentation)) #1# 31898) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 14 12 14 15 9 2 19 4 16 15 0 15 17 15 18 19 3 19 1 0 73 29) #50=#A(t (20) (common-lisp-user::vtheta ext::location (defmacro common-lisp-user::vtheta) (#1# . 31975) ext::annotate :lambda-list (common-lisp-user::vrt) #:g207 #:g206 #:g208 si::dm-too-few-arguments common-lisp-user::vrt si::dm-too-many-arguments svref #Y(common-lisp-user::vtheta nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 1 39 6 13 3 19 1 12 15 13 13 0 8 1 6 3 73 29) #50# #1# 31975) t si::fset function "Theta component of an r-theta vector." si::set-documentation)) #1# 31975) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 11 12 19 2 12 1 0 73 29) #51=#A(t (13) (common-lisp-user::vpt= ext::location (defun common-lisp-user::vpt=) (#1# . 32060) ext::annotate :lambda-list (common-lisp-user::vpt1 common-lisp-user::vpt2) common-lisp-user::vpt1 common-lisp-user::vpt2 svref = #Y(common-lisp-user::vpt= nil nil (24 45 7 24 45 8 26 13 1 8 0 17 9 12 13 0 8 0 17 9 12 19 2 10 73 39 18 13 1 8 1 17 9 12 13 0 8 1 17 9 12 19 2 10 29) #51# #1# 32060) si::fset)) #1# 32060) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 11 12 19 2 12 1 0 73 29) #52=#A(t (13) (common-lisp-user::round-xy ext::location (defun common-lisp-user::round-xy) (#1# . 32150) ext::annotate :lambda-list (common-lisp-user::loc) common-lisp-user::loc vector round map #Y(common-lisp-user::round-xy nil nil (24 45 7 26 15 8 33 9 12 13 0 19 3 10 29) #52# #1# 32150) si::fset)) #1# 32150) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 14 7 14 8 14 5 15 6 15 9 15 10 19 7 11 29) #A(t (12) (common-lisp-user::polar-move-xy ext::location (defgeneric common-lisp-user::polar-move-xy) (#1# . 32202) ext::annotate :lambda-list (common-lisp-user::loc common-lisp-user::move) :delete-methods t :documentation "Given an xy location and a polar displacement, return new xy" ensure-generic-function)) #1# 32202) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 15 12 14 16 19 6 17 29) #53=#A(t (18) (common-lisp-user::polar-move-xy ext::location (defmethod common-lisp-user::polar-move-xy (common-lisp-user::loc vector) (common-lisp-user::move vector)) (#1# . 32328) ext::annotate (vector vector) (common-lisp-user::loc common-lisp-user::move) common-lisp-user::loc common-lisp-user::move svref cos * + sin common-lisp-user::round-xy #Y(common-lisp-user::polar-move-xy nil nil (24 45 7 24 45 8 26 13 1 8 0 17 9 12 13 0 8 0 17 9 12 13 0 8 1 17 9 16 10 12 19 2 11 12 19 2 12 12 13 1 8 1 17 9 12 13 0 8 0 17 9 12 13 0 8 1 17 9 16 13 12 19 2 11 12 19 2 12 6 2 12 19 1 14 29) #53# #1# 32328) t clos::install-method)) #1# 32328) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 11 12 14 12 19 6 13 29) #54=#A(t (14) (common-lisp-user::polar-move-xy ext::location (defmethod common-lisp-user::polar-move-xy (common-lisp-user::loc list) (common-lisp-user::move list)) (#1# . 32502) ext::annotate (list list) (common-lisp-user::loc common-lisp-user::move) common-lisp-user::loc common-lisp-user::move vector coerce #Y(common-lisp-user::polar-move-xy nil nil (24 45 7 24 45 8 26 13 1 1 9 17 10 12 13 0 1 9 17 10 12 19 2 0 29) #54# #1# 32502) t clos::install-method)) #1# 32502) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 21 12 19 2 22 1 0 73 29) #55=#A(t (23) (common-lisp-user::dist ext::location (defun common-lisp-user::dist) (#1# . 32615) ext::annotate :lambda-list (common-lisp-user::loc1 common-lisp-user::loc2) common-lisp-user::loc1 common-lisp-user::loc2 + vector common-lisp-user::x1 common-lisp-user::x2 numberp - expt #Y(nil nil nil (24 45 11 24 45 12 26 10 1 16 13 39 5 10 0 16 13 39 15 13 1 13 0 19 2 14 12 8 2 17 15 38 4 8 0 73 29) #55# #1# 32615) map :initial-value reduce sqrt #Y(common-lisp-user::dist nil nil (24 45 7 24 45 8 26 15 9 15 10 34 16 12 13 1 13 0 19 4 17 12 14 18 9 0 19 4 19 16 20 29) #55# #1# 32615) si::fset)) #1# 32615) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 14 7 14 8 14 5 15 6 15 9 15 10 19 7 11 29) #A(t (12) (common-lisp-user::objs-match-slotval ext::location (defgeneric common-lisp-user::objs-match-slotval) (#1# . 33127) ext::annotate :lambda-list (common-lisp-user::lst common-lisp-user::slot-name common-lisp-user::value) :delete-methods t :documentation "Takes a list of CLOS objects and returns a list containing those items which have the slot <slot-name> equal to <value>." ensure-generic-function)) #1# 33127) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 16 12 14 17 19 6 18 29) #56=#A(t (19) (common-lisp-user::objs-match-slotval ext::location (defmethod common-lisp-user::objs-match-slotval (common-lisp-user::ls list) (common-lisp-user::slot-name symbol) common-lisp-user::value) (#1# . 33329) ext::annotate (list symbol t) (common-lisp-user::ls common-lisp-user::slot-name common-lisp-user::value) common-lisp-user::ls common-lisp-user::slot-name common-lisp-user::value common-lisp-user::accum si::%dolist-var common-lisp-user::obj slot-value equal nreverse #Y(common-lisp-user::objs-match-slotval nil nil (24 45 7 24 45 8 24 45 9 26 10 2 73 39 57 75 45 10 10 3 45 11 75 45 12 38 30 10 1 4 51 0 13 3 13 0 10 4 17 13 17 14 39 8 13 0 10 2 3 51 2 10 1 5 51 1 10 1 40 -32 75 51 0 10 2 16 15 43 2 43 1 29) #56# #1# 33329) t clos::install-method)) #1# 33329) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 16 12 14 17 19 6 18 29) #57=#A(t (19) (common-lisp-user::objs-match-slotval ext::location (defmethod common-lisp-user::objs-match-slotval (common-lisp-user::ls list) (common-lisp-user::slot-name symbol) (common-lisp-user::value number)) (#1# . 33552) ext::annotate (list symbol number) (common-lisp-user::ls common-lisp-user::slot-name common-lisp-user::value) common-lisp-user::ls common-lisp-user::slot-name common-lisp-user::value common-lisp-user::accum si::%dolist-var common-lisp-user::obj slot-value = nreverse #Y(common-lisp-user::objs-match-slotval nil nil (24 45 7 24 45 8 24 45 9 26 10 2 73 39 59 75 45 10 10 3 45 11 75 45 12 38 32 10 1 4 51 0 13 3 13 0 10 4 17 13 12 19 2 14 39 8 13 0 10 2 3 51 2 10 1 5 51 1 10 1 40 -34 75 51 0 10 2 16 15 43 2 43 1 29) #57# #1# 33552) t clos::install-method)) #1# 33552) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 16 12 14 17 19 6 18 29) #58=#A(t (19) (common-lisp-user::objs-match-slotval ext::location (defmethod common-lisp-user::objs-match-slotval (common-lisp-user::ls list) (common-lisp-user::slot-name symbol) (common-lisp-user::value symbol)) (#1# . 33816) ext::annotate (list symbol symbol) (common-lisp-user::ls common-lisp-user::slot-name common-lisp-user::value) common-lisp-user::ls common-lisp-user::slot-name common-lisp-user::value common-lisp-user::accum si::%dolist-var common-lisp-user::obj slot-value eq nreverse #Y(common-lisp-user::objs-match-slotval nil nil (24 45 7 24 45 8 24 45 9 26 10 2 73 39 57 75 45 10 10 3 45 11 75 45 12 38 30 10 1 4 51 0 13 3 13 0 10 4 17 13 17 14 39 8 13 0 10 2 3 51 2 10 1 5 51 1 10 1 40 -32 75 51 0 10 2 16 15 43 2 43 1 29) #58# #1# 33816) t clos::install-method)) #1# 33816) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 14 7 14 8 14 5 15 6 15 9 15 10 19 7 11 29) #A(t (12) (common-lisp-user::objs-min-slotval ext::location (defgeneric common-lisp-user::objs-min-slotval) (#1# . 34081) ext::annotate :lambda-list (common-lisp-user::lst common-lisp-user::slot-name) :delete-methods t :documentation "Given a list of CLOS objects and a slot name, return a list containing the object(s) with the lowest value for that slot." ensure-generic-function)) #1# 34081) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 18 12 14 19 19 6 20 29) #59=#A(t (21) (common-lisp-user::objs-min-slotval ext::location (defmethod common-lisp-user::objs-min-slotval (common-lisp-user::ls list) (common-lisp-user::slot-name symbol)) (#1# . 34276) ext::annotate (list symbol) (common-lisp-user::ls common-lisp-user::slot-name) common-lisp-user::ls common-lisp-user::slot-name slot-value common-lisp-user::out-ls common-lisp-user::current common-lisp-user::best si::%dolist-var common-lisp-user::obj = < nreverse #Y(common-lisp-user::objs-min-slotval nil nil (24 45 7 24 45 8 26 10 1 73 39 103 10 1 4 12 10 0 17 9 12 77 10 1 4 6 1 12 46 10 46 11 46 12 10 4 5 45 13 75 45 14 38 56 10 1 4 51 0 13 0 10 5 17 9 51 3 13 3 13 2 19 2 15 39 10 13 0 10 4 3 51 4 38 20 13 3 13 2 19 2 16 39 11 10 3 51 2 10 0 6 1 51 4 10 1 5 51 1 10 1 40 -58 75 51 0 10 4 16 17 43 2 43 3 29) #59# #1# 34276) t clos::install-method)) #1# 34276) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 14 7 14 8 14 5 15 6 15 9 15 10 19 7 11 29) #A(t (12) (common-lisp-user::objs-max-slotval ext::location (defgeneric common-lisp-user::objs-max-slotval) (#1# . 34723) ext::annotate :lambda-list (common-lisp-user::lst common-lisp-user::slot-name) :delete-methods t :documentation "Given a list of CLOS objects and a slot name, return a list containing the object(s) with the highest value for that slot." ensure-generic-function)) #1# 34723) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 18 12 14 19 19 6 20 29) #60=#A(t (21) (common-lisp-user::objs-max-slotval ext::location (defmethod common-lisp-user::objs-max-slotval (common-lisp-user::ls list) (common-lisp-user::slot-name symbol)) (#1# . 34919) ext::annotate (list symbol) (common-lisp-user::ls common-lisp-user::slot-name) common-lisp-user::ls common-lisp-user::slot-name slot-value common-lisp-user::out-ls common-lisp-user::current common-lisp-user::best si::%dolist-var common-lisp-user::obj = > nreverse #Y(common-lisp-user::objs-max-slotval nil nil (24 45 7 24 45 8 26 10 1 73 39 103 10 1 4 12 10 0 17 9 12 77 10 1 4 6 1 12 46 10 46 11 46 12 10 4 5 45 13 75 45 14 38 56 10 1 4 51 0 13 0 10 5 17 9 51 3 13 3 13 2 19 2 15 39 10 13 0 10 4 3 51 4 38 20 13 3 13 2 19 2 16 39 11 10 3 51 2 10 0 6 1 51 4 10 1 5 51 1 10 1 40 -58 75 51 0 10 4 16 17 43 2 43 3 29) #60# #1# 34919) t clos::install-method)) #1# 34919) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 14 7 14 8 14 5 15 6 15 9 15 10 19 7 11 29) #A(t (12) (common-lisp-user::objs-nearest-slotval ext::location (defgeneric common-lisp-user::objs-nearest-slotval) (#1# . 35366) ext::annotate :lambda-list (common-lisp-user::lst common-lisp-user::slot-name common-lisp-user::val) :delete-methods t :documentation "Given a list of CLOS objects and a slot name, return a list containing the objects with the slot value closest to the supplied value." ensure-generic-function)) #1# 35366) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 21 12 14 22 19 6 23 29) #61=#A(t (24) (common-lisp-user::objs-nearest-slotval ext::location (defmethod common-lisp-user::objs-nearest-slotval (common-lisp-user::lst list) (common-lisp-user::slot-name symbol) (common-lisp-user::val number)) (#1# . 35580) ext::annotate (list symbol number) (common-lisp-user::lst common-lisp-user::slot-name common-lisp-user::val) common-lisp-user::lst common-lisp-user::slot-name common-lisp-user::val slot-value - abs common-lisp-user::out-lst common-lisp-user::current common-lisp-user::best si::%dolist-var common-lisp-user::obj = < nreverse #Y(common-lisp-user::objs-nearest-slotval nil nil (24 45 7 24 45 8 24 45 9 26 13 0 10 2 4 12 10 1 17 10 12 19 2 11 16 12 12 77 10 2 4 6 1 12 46 13 46 14 46 15 10 5 5 45 16 75 45 17 38 64 10 1 4 51 0 13 5 13 0 10 6 17 10 12 19 2 11 16 12 51 3 13 3 13 2 19 2 18 39 10 13 0 10 4 3 51 4 38 20 13 3 13 2 19 2 19 39 11 10 3 51 2 10 0 6 1 51 4 10 1 5 51 1 10 1 40 -66 75 51 0 10 4 16 20 43 2 43 3 29) #61# #1# 35580) t clos::install-method)) #1# 35580) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 16 12 19 2 17 1 0 73 29) #62=#A(t (18) (common-lisp-user::objs-min-val ext::location (defun common-lisp-user::objs-min-val) (#1# . 36089) ext::annotate :lambda-list (list common-lisp-user::accessor) list common-lisp-user::accessor common-lisp-user::matches common-lisp-user::value si::%dolist-var common-lisp-user::y common-lisp-user::cur-val < = #Y(common-lisp-user::objs-min-val nil nil (24 45 7 24 45 8 26 77 77 46 9 46 10 10 3 45 11 75 45 12 38 64 10 1 4 51 0 13 4 13 0 20 1 23 45 13 10 3 76 40 8 13 0 13 3 19 2 14 39 13 10 0 51 3 10 1 6 1 51 4 38 17 13 0 13 3 19 2 15 39 8 13 1 10 4 3 51 4 43 1 10 1 5 51 1 10 1 40 -66 43 2 10 1 73 43 2 29) #62# #1# 36089) si::fset)) #1# 36089) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 16 12 19 2 17 1 0 73 29) #63=#A(t (18) (common-lisp-user::objs-max-val ext::location (defun common-lisp-user::objs-max-val) (#1# . 36549) ext::annotate :lambda-list (list common-lisp-user::accessor) list common-lisp-user::accessor common-lisp-user::matches common-lisp-user::value si::%dolist-var common-lisp-user::y common-lisp-user::cur-val > = #Y(common-lisp-user::objs-max-val nil nil (24 45 7 24 45 8 26 77 77 46 9 46 10 10 3 45 11 75 45 12 38 64 10 1 4 51 0 13 4 13 0 20 1 23 45 13 10 3 76 40 8 13 0 13 3 19 2 14 39 13 10 0 51 3 10 1 6 1 51 4 38 17 13 0 13 3 19 2 15 39 8 13 1 10 4 3 51 4 43 1 10 1 5 51 1 10 1 40 -66 43 2 10 1 73 43 2 29) #63# #1# 36549) si::fset)) #1# 36549) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 14 12 19 2 15 15 0 15 16 15 17 19 3 18 1 0 73 29) #64=#A(t (19) (common-lisp-user::mkstr ext::location (defun common-lisp-user::mkstr) (#1# . 36944) ext::annotate :lambda-list (&rest common-lisp-user::args) common-lisp-user::args make-string-output-stream common-lisp-user::s si::%dolist-var common-lisp-user::a princ get-output-stream-string #Y(common-lisp-user::mkstr nil nil (27 45 7 19 0 8 45 9 10 1 45 10 75 45 11 38 18 10 1 4 51 0 13 0 13 2 19 2 12 10 1 5 51 1 10 1 40 -20 43 2 10 0 16 13 43 1 29) #64# #1# 36944) si::fset function "Return a concatenated string representation of the arguments" si::set-documentation)) #1# 36944) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 14 7 14 8 14 5 15 6 15 9 15 10 19 7 11 29) #A(t (12) (common-lisp-user::random-item ext::location (defgeneric common-lisp-user::random-item) (#1# . 37227) ext::annotate :lambda-list (common-lisp-user::seq) :delete-methods t :documentation "Returns a random item from a sequence using act-r-random." ensure-generic-function)) #1# 37227) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 11 12 14 12 19 6 13 29) #65=#A(t (14) (common-lisp-user::random-item ext::location (defmethod common-lisp-user::random-item (common-lisp-user::seq list)) (#1# . 37340) ext::annotate (list) (common-lisp-user::seq) common-lisp-user::seq length common-lisp-user::act-r-random nth #Y(common-lisp-user::random-item nil nil (24 45 7 26 10 0 16 8 12 19 1 9 12 10 0 17 10 29) #65# #1# 37340) t clos::install-method)) #1# 37340) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 11 12 14 12 19 6 13 29) #66=#A(t (14) (common-lisp-user::random-item ext::location (defmethod common-lisp-user::random-item (common-lisp-user::seq vector)) (#1# . 37418) ext::annotate (vector) (common-lisp-user::seq) common-lisp-user::seq length common-lisp-user::act-r-random svref #Y(common-lisp-user::random-item nil nil (24 45 7 26 13 0 10 0 16 8 12 19 1 9 17 10 29) #66# #1# 37418) t clos::install-method)) #1# 37418) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 11 12 14 12 19 6 13 29) #67=#A(t (14) (common-lisp-user::random-item ext::location (defmethod common-lisp-user::random-item (common-lisp-user::seq sequence)) (#1# . 37615) ext::annotate (sequence) (common-lisp-user::seq) common-lisp-user::seq length common-lisp-user::act-r-random elt #Y(common-lisp-user::random-item nil nil (24 45 7 26 13 0 10 0 16 8 12 19 1 9 17 10 29) #67# #1# 37615) t clos::install-method)) #1# 37615) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 8 12 14 9 19 6 10 29) #68=#A(t (11) (common-lisp-user::random-item ext::location (defmethod common-lisp-user::random-item (common-lisp-user::seq null)) (#1# . 37698) ext::annotate (null) (common-lisp-user::seq) common-lisp-user::seq #Y(common-lisp-user::random-item nil nil (24 45 7 26 75 73 29) #68# #1# 37698) t clos::install-method)) #1# 37698) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #69=#A(t (16) (common-lisp-user::sym->key ext::location (defun common-lisp-user::sym->key) (#1# . 37770) ext::annotate :lambda-list (symbol) symbol ":" common-lisp-user::mkstr read-from-string #Y(common-lisp-user::sym->key nil nil (24 45 7 26 15 8 13 0 19 2 9 12 19 1 10 29) #69# #1# 37770) si::fset function "Given a symbol, return the corresponding keyword." si::set-documentation)) #1# 37770) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 11 12 19 2 12 15 0 15 13 15 14 19 3 15 1 0 73 29) #70=#A(t (16) (common-lisp-user::flatten ext::location (defun common-lisp-user::flatten) (#1# . 37891) ext::annotate :lambda-list (common-lisp-user::lis) common-lisp-user::lis common-lisp-user::acc atom #Y(common-lisp-user::rec nil nil (24 45 7 24 45 8 26 10 1 76 39 6 10 0 73 38 34 10 1 16 9 39 9 13 1 10 0 3 73 38 20 10 1 4 12 10 1 5 12 13 0 32 2 18 2 12 32 2 18 2 29) #70# #1# 37891) #Y(common-lisp-user::flatten nil nil (24 45 7 26 31 1 10 13 1 77 32 0 18 2 43 1 29) #70# #1# 37891) si::fset function "Takes a nested list and makes in into a single-level list" si::set-documentation)) #1# 37891) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 25 12 14 26 9 2 19 4 27 1 0 73 29) #71=#A(t (28) (common-lisp-user::dovector ext::location (defmacro common-lisp-user::dovector) (#1# . 38347) ext::annotate :lambda-list ((common-lisp-user::varsym common-lisp-user::vec &optional common-lisp-user::ret) &body common-lisp-user::body) #:g354 #:g353 #:g355 si::dm-too-few-arguments #:g356 #:g357 common-lisp-user::varsym common-lisp-user::vec common-lisp-user::ret common-lisp-user::body si::dm-too-many-arguments gensym common-lisp-user::idx let dotimes length setq aref #Y(common-lisp-user::dovector nil nil (24 45 7 24 45 8 26 10 1 5 45 9 10 0 76 39 6 13 2 19 1 10 10 0 4 12 10 0 5 51 0 22 45 11 10 0 45 12 10 0 76 39 6 13 4 19 1 10 10 0 4 12 10 0 5 51 0 22 45 13 10 1 76 39 6 13 5 19 1 10 10 1 4 12 10 1 5 51 1 22 45 14 10 2 39 13 10 2 4 12 10 2 5 51 2 22 38 2 75 45 15 10 5 45 16 10 4 39 6 13 8 19 1 17 19 0 18 45 19 15 20 13 4 75 6 2 6 1 12 15 21 13 0 15 22 10 3 6 2 12 10 2 6 3 12 15 23 13 4 15 24 13 3 10 0 6 3 6 3 12 10 1 7 4 6 3 73 43 1 29) #71# #1# 38347) t si::fset)) #1# 38347) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 14 7 14 8 14 5 15 6 15 9 15 10 19 7 11 29) #A(t (12) (common-lisp-user::within ext::location (defgeneric common-lisp-user::within) (#1# . 38609) ext::annotate :lambda-list (min max) :delete-methods t :documentation "Returns a closure that will test whether the argument is betwen <min> and <max>, inclusive." ensure-generic-function)) #1# 38609) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 14 12 14 15 19 6 16 29) #72=#A(t (17) (common-lisp-user::within ext::location (defmethod common-lisp-user::within (min number) (max number)) (#1# . 38758) ext::annotate (number number) (min max) min max common-lisp-user::val numberp <= >= #Y(nil nil nil (24 45 9 26 10 0 16 10 73 39 18 13 0 13 1 19 2 11 73 39 8 13 0 13 2 19 2 12 29) #72# #1# 38758) #Y(common-lisp-user::within nil nil (24 45 7 24 45 8 26 34 13 73 29) #72# #1# 38758) t clos::install-method)) #1# 38758) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 14 7 14 8 14 5 15 6 15 9 15 10 19 7 11 29) #A(t (12) (common-lisp-user::greater-than ext::location (defgeneric common-lisp-user::greater-than) (#1# . 38873) ext::annotate :lambda-list (common-lisp-user::criterion) :delete-methods t :documentation "Returns a closure that will return whether or not the argument is greater than <criterion>." ensure-generic-function)) #1# 38873) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 12 12 14 13 19 6 14 29) #73=#A(t (15) (common-lisp-user::greater-than ext::location (defmethod common-lisp-user::greater-than (common-lisp-user::criterion number)) (#1# . 39283) ext::annotate (number) (common-lisp-user::criterion) common-lisp-user::criterion common-lisp-user::val numberp > #Y(nil nil nil (24 45 8 26 10 0 16 9 73 39 8 13 0 13 1 19 2 10 29) #73# #1# 39283) #Y(common-lisp-user::greater-than nil nil (24 45 7 26 34 11 73 29) #73# #1# 39283) t clos::install-method)) #1# 39283) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 14 7 14 8 14 5 15 6 15 9 15 10 19 7 11 29) #A(t (12) (common-lisp-user::less-than ext::location (defgeneric common-lisp-user::less-than) (#1# . 39389) ext::annotate :lambda-list (common-lisp-user::criterion) :delete-methods t :documentation "Returns a closure that will return whether or not the argument is less than <criterion>." ensure-generic-function)) #1# 39389) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 77 15 5 15 6 1 12 12 14 13 19 6 14 29) #74=#A(t (15) (common-lisp-user::less-than ext::location (defmethod common-lisp-user::less-than (common-lisp-user::criterion number)) (#1# . 39629) ext::annotate (number) (common-lisp-user::criterion) common-lisp-user::criterion common-lisp-user::val numberp < #Y(nil nil nil (24 45 8 26 10 0 16 9 73 39 8 13 0 13 1 19 2 10 29) #74# #1# 39629) #Y(common-lisp-user::less-than nil nil (24 45 7 26 34 11 73 29) #74# #1# 39629) t clos::install-method)) #1# 39629) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 11 12 19 2 12 1 0 73 29) #75=#A(t (13) (common-lisp-user::not-equal ext::location (defun common-lisp-user::not-equal) (#1# . 39732) ext::annotate :lambda-list (common-lisp-user::x) common-lisp-user::x common-lisp-user::val equal #Y(nil nil nil (24 45 8 26 13 1 10 0 17 9 76 73 29) #75# #1# 39732) #Y(common-lisp-user::not-equal nil nil (24 45 7 26 34 10 73 29) #75# #1# 39732) si::fset)) #1# 39732) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 10 12 19 2 11 15 0 15 12 15 13 19 3 14 1 0 73 29) #76=#A(t (15) (common-lisp-user::neq ext::location (defun common-lisp-user::neq) (#1# . 39911) ext::annotate :lambda-list (common-lisp-user::x common-lisp-user::y) common-lisp-user::x common-lisp-user::y eq #Y(common-lisp-user::neq nil nil (24 45 7 24 45 8 26 13 1 10 0 17 9 76 73 29) #76# #1# 39911) si::fset function "The NOT of EQ." si::set-documentation)) #1# 39911) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 16 12 19 2 17 1 0 73 29) #77=#A(t (18) (common-lisp-user::string-to-lines ext::location (defun common-lisp-user::string-to-lines) (#1# . 40025) ext::annotate :lambda-list (common-lisp-user::s) common-lisp-user::s #\Newline position common-lisp-user::it subseq common-lisp-user::mklist 1+ length append #Y(common-lisp-user::string-to-lines nil nil (24 45 7 26 15 8 13 0 19 2 9 45 10 10 0 39 40 13 1 9 0 13 0 19 3 11 12 19 1 12 12 13 1 10 0 16 13 12 10 1 16 14 12 19 3 11 12 19 1 0 12 19 2 15 38 6 10 1 6 1 73 43 1 29) #77# #1# 40025) si::fset)) #1# 40025) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 22 12 19 2 23 1 0 73 29) #78=#A(t (24) (common-lisp-user::find-float-time-limit ext::location (defun common-lisp-user::find-float-time-limit) (#1# . 40197) ext::annotate :lambda-list (common-lisp-user::size &optional (common-lisp-user::digits 3)) common-lisp-user::size common-lisp-user::digits 1.0 coerce float-radix common-lisp-user::radix float-precision common-lisp-user::precision expt log common-lisp-user::significant - 0.1 floor / #Y(common-lisp-user::find-float-time-limit nil nil (24 45 7 25 40 3 9 3 46 8 26 15 9 10 1 17 10 16 11 45 12 15 9 10 2 17 10 16 13 45 14 13 1 10 0 17 15 12 9 10 19 2 16 45 17 13 4 9 10 13 0 13 3 19 2 18 12 15 19 19 2 20 12 9 10 19 2 21 17 15 12 10 4 17 10 3 73 43 3 29) #78# #1# 40197) si::fset)) #1# 40197) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 19 15 3 15 4 15 5 15 6 1 7 6 4 12 19 2 8 52 0 15 0 15 9 15 10 15 11 19 4 12 1 0 73 29) #A(t (13) (common-lisp-user::*time-size-test-list* si::*make-special boundp common-lisp-user::find-float-time-limit short-float single-float double-float long-float mapcar ext::location (defvar common-lisp-user::*time-size-test-list*) (#1# . 40506) ext::annotate)) #1# 40506) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 15 0 15 4 15 5 15 6 19 4 7 1 0 73 29) #A(t (8) (common-lisp-user::*time-size-current-type* si::*make-special boundp *read-default-float-format* ext::location (defvar common-lisp-user::*time-size-current-type*) (#1# . 40662) ext::annotate)) #1# 40662) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 71 12 19 2 72 1 0 73 29) #79=#A(t (73) (common-lisp-user::safe-seconds->ms ext::location (defun common-lisp-user::safe-seconds->ms) (#1# . 40836) ext::annotate :lambda-list (common-lisp-user::seconds &optional common-lisp-user::fname) common-lisp-user::seconds common-lisp-user::fname floatp type-of type common-lisp-user::*time-size-test-list* assoc common-lisp-user::size common-lisp-user::find-float-time-limit #:g372 nconc abs > common-lisp-user::x #Y(nil nil nil (24 45 20 26 10 0 5 12 10 1 5 12 19 2 19 29) #79# #1# 40836) find-if common-lisp-user::larger single-float #\f double-float #\d long-float #\L common-lisp-user::marker "specify the time in milliseconds if the command that was used has such an option" "use a rational number instead of a float e.g. 1234567/1000 instead of 1234.567" common-lisp-user::options "change the default floating point format to a higher precision type like ~s and recompile the ACT-R sources" format #:g374 "directly specify the time as a higher precision floating point type e.g. 1234.567~c0" #:g376 common-lisp-user::printing-module common-lisp-user::get-module-fct #:g378 #:g377 common-lisp-user::printing-module-v common-lisp-user::act-r-output-stream #:g379 :large-seconds common-lisp-user::printing-module-one-time-tags :test equal find #:g380 #:g381 (setf common-lisp-user::printing-module-one-time-tags) common-lisp-user::printing-module-model-warnings *error-output* eq common-lisp-user::*one-stream-hack* t *standard-output* eql #40# common-lisp-user::mp-models length common-lisp-user::current-model "A time of ~f seconds was specified~@[ in a call to the ~a command~] which is beyond the limit to accurately represent time in milliseconds for the floating point type of that number (~s).~%To avoid potential problems you could do one of the following:~%~{ - ~a~%~}" finish-output #41# #42# * round #Y(common-lisp-user::safe-seconds->ms nil nil (24 45 7 25 40 2 77 46 8 26 10 1 16 9 39 404 10 1 16 10 45 11 13 0 14 12 19 2 13 45 14 10 0 76 39 25 13 1 19 1 15 51 0 10 0 6 1 45 16 14 12 13 0 19 2 17 52 12 43 1 10 3 16 18 12 10 0 5 12 19 2 19 39 344 34 21 12 14 12 19 2 22 45 23 10 0 4 42 24 5 1 25 38 16 42 26 5 1 27 38 9 42 28 5 1 29 38 2 75 45 30 15 31 1 32 6 2 45 33 10 2 39 26 77 15 34 10 2 4 12 19 3 35 6 1 45 36 13 1 13 0 19 2 17 51 1 43 1 10 1 39 24 77 15 37 13 1 19 3 35 6 1 45 38 13 1 13 0 19 2 17 51 1 43 1 15 39 19 1 40 47 1 41 45 42 10 1 39 10 13 0 19 1 43 12 19 1 44 39 214 13 0 19 1 43 12 19 1 44 45 45 14 46 13 1 19 1 47 12 14 48 15 49 19 4 50 76 39 183 10 1 45 51 14 46 13 0 19 1 47 3 45 52 13 0 13 1 33 53 18 2 43 2 13 1 19 1 54 76 40 151 10 0 76 40 27 13 0 11 55 17 56 40 19 11 57 40 15 13 0 11 58 17 56 39 7 14 55 11 59 17 60 39 43 14 55 15 61 19 0 62 16 63 12 9 1 19 2 19 12 19 0 64 12 15 65 13 9 13 8 10 6 4 12 13 3 19 9 35 14 55 19 1 66 38 76 14 55 15 67 19 0 62 16 63 12 9 1 19 2 19 12 19 0 64 12 15 65 13 9 13 8 10 6 4 12 13 3 19 9 35 14 55 19 1 66 13 0 15 68 19 0 62 16 63 12 9 1 19 2 19 12 19 0 64 12 15 65 13 9 13 8 10 6 4 12 13 3 19 9 35 43 1 43 2 43 3 43 2 13 1 9 1000 19 2 69 12 19 1 70 29) #79# #1# 40836) si::fset)) #1# 40836) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 27 12 19 2 28 15 0 15 29 15 30 19 3 31 1 0 73 29) #80=#A(t (32) (common-lisp-user::circular-references ext::location (defun common-lisp-user::circular-references) (#1# . 42441) ext::annotate :lambda-list (common-lisp-user::dependencies) common-lisp-user::dependencies si::%dolist-var common-lisp-user::x common-lisp-user::y :test common-lisp-user::i common-lisp-user::j listp find eq #Y(nil nil nil (24 45 12 24 45 13 26 10 0 4 16 14 39 12 13 1 10 0 4 12 19 2 15 38 8 13 1 10 0 4 17 16 29) #80# #1# 42441) common-lisp-user::it #:g396 append #:g397 rplacd common-lisp-user::z #Y(nil nil nil (24 45 23 26 13 0 10 1 5 12 19 2 15 29) #80# #1# 42441) some #Y(nil nil nil (24 45 9 26 10 0 4 16 14 39 13 34 24 12 10 0 4 12 19 2 25 38 12 10 0 4 12 10 0 5 12 19 2 15 29) #80# #1# 42441) #Y(common-lisp-user::circular-references nil nil (24 45 7 26 10 0 45 8 75 45 9 38 88 10 1 4 51 0 10 0 5 45 8 75 45 10 38 62 10 1 4 51 0 13 0 13 4 14 11 34 17 12 19 4 15 45 18 10 0 39 32 10 3 45 19 10 4 5 12 10 1 5 12 19 2 20 45 21 13 1 10 0 17 22 10 0 43 1 43 1 38 1 43 1 10 1 5 51 1 10 1 40 -64 43 2 10 1 5 51 1 10 1 40 -90 43 2 34 26 12 13 0 19 2 25 29) #80# #1# 42441) si::fset function "Modify the dependencies lists passed and return t if there are any circularities" si::set-documentation)) #1# 42441) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 16 12 19 2 17 1 0 73 29) #81=#A(t (18) (common-lisp-user::chunk-spec-variable-p ext::location (defun common-lisp-user::chunk-spec-variable-p) (#1# . 43094) ext::annotate :lambda-list (common-lisp-user::chunk-spec-slot-value &optional (char #\=)) common-lisp-user::chunk-spec-slot-value #\= char symbolp string length > symbol-name char-equal #Y(common-lisp-user::chunk-spec-variable-p nil nil (24 45 7 25 40 3 15 8 46 9 26 10 1 16 10 73 39 31 10 1 16 11 16 12 12 9 1 19 2 13 73 39 16 10 1 16 14 12 8 0 17 9 12 13 0 19 2 15 29) #81# #1# 43094) si::fset)) #1# 43094) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 19 12 19 2 20 1 0 73 29) #82=#A(t (21) (common-lisp-user::replace-variables ext::location (defun common-lisp-user::replace-variables) (#1# . 43335) ext::annotate :lambda-list (common-lisp-user::arg common-lisp-user::bindings) common-lisp-user::arg common-lisp-user::bindings consp last eq listp common-lisp-user::x #Y(nil nil nil (24 45 13 26 13 0 13 1 19 2 0 29) #82# #1# 43335) mapcar common-lisp-user::chunk-spec-variable-p assoc common-lisp-user::it #Y(common-lisp-user::replace-variables nil nil (24 45 7 24 45 8 26 10 1 16 9 39 11 13 1 19 1 10 12 10 1 17 11 39 24 10 1 4 12 13 0 19 2 0 12 10 1 5 12 13 0 19 2 0 3 73 38 53 10 1 16 12 39 11 34 14 12 13 1 19 2 15 38 37 13 1 19 1 16 39 27 13 1 13 0 19 2 17 45 18 10 0 39 7 10 0 5 73 38 4 10 2 73 43 1 38 4 10 1 73 29) #82# #1# 43335) si::fset)) #1# 43335) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 26 12 19 2 27 1 0 73 29) #83=#A(t (28) (common-lisp-user::print-time-in-seconds ext::location (defun common-lisp-user::print-time-in-seconds) (#1# . 43844) ext::annotate :lambda-list (stream time common-lisp-user::colon-p common-lisp-user::atsign-p &optional (common-lisp-user::width 0) common-lisp-user::padchar common-lisp-user::commachar) stream time common-lisp-user::colon-p common-lisp-user::atsign-p common-lisp-user::width common-lisp-user::padchar common-lisp-user::commachar truncate common-lisp-user::ms common-lisp-user::sec "~d.~3,'0d" format common-lisp-user::digits length - max common-lisp-user::pad "~va~a" "" #Y(common-lisp-user::print-time-in-seconds nil nil (24 45 7 24 45 8 24 45 9 24 45 10 25 40 3 9 0 46 11 25 40 2 77 46 12 25 40 2 77 46 13 26 13 5 9 1000 19 2 14 47 1 15 45 16 77 15 17 13 0 13 1 19 4 18 45 19 9 0 13 5 10 0 16 20 12 19 2 21 12 19 2 22 45 23 13 10 15 24 13 0 15 25 13 1 19 5 18 43 2 43 2 29) #83# #1# 43844) si::fset)) #1# 43844))
