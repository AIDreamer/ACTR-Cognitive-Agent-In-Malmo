(#Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 38 12 19 2 39 1 0 73 29) #1=#A(t (40) (common-lisp-user::compose-motor-buffer ext::location (defun common-lisp-user::compose-motor-buffer) (#2=#P"C:/Users/Son Pham/Desktop/actr7/tools/motor-compilation.lisp" . 0) ext::annotate :lambda-list (common-lisp-user::p1 common-lisp-user::p1-s common-lisp-user::p2 common-lisp-user::p2-s common-lisp-user::buffer) common-lisp-user::p1 common-lisp-user::p1-s common-lisp-user::p2 common-lisp-user::p2-s common-lisp-user::buffer string symbol-name ">" concatenate intern common-lisp-user::bn "+" common-lisp-user::b+ "?" common-lisp-user::b? :key car find copy-tree common-lisp-user::q1 common-lisp-user::q2 second common-lisp-user::a1+ common-lisp-user::a2+ common-lisp-user::production-buffer-indices assoc common-lisp-user::it 0 4 16 20 #Y(common-lisp-user::compose-motor-buffer nil nil (24 45 7 24 45 8 24 45 9 24 45 10 24 45 11 26 15 12 10 0 16 13 12 15 14 19 3 15 12 19 1 16 45 17 15 12 15 18 10 0 16 13 12 19 3 15 12 19 1 16 45 19 15 12 15 20 10 1 16 13 12 19 3 15 12 19 1 16 45 21 13 0 10 6 4 12 14 22 15 23 19 4 24 16 25 45 26 13 1 10 5 4 12 14 22 15 23 19 4 24 16 25 45 27 13 3 10 8 16 28 12 14 22 15 23 19 4 24 16 25 45 29 13 4 10 7 16 28 12 14 22 15 23 19 4 24 16 25 45 30 13 7 13 11 19 1 31 12 19 2 32 5 45 33 10 0 39 5 10 0 38 3 8 0 43 1 42 34 25 10 2 73 39 6 10 2 6 1 73 12 10 0 39 5 10 0 6 1 6 2 73 38 74 42 35 15 77 10 1 39 5 10 1 6 1 6 2 73 38 57 42 36 25 10 3 73 39 6 10 3 6 1 73 12 10 0 39 5 10 0 6 1 6 2 73 38 30 42 37 25 10 3 73 39 6 10 3 6 1 73 12 10 1 39 5 10 1 6 1 6 2 73 38 3 75 73 43 7 29) #1# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 25 12 19 2 26 15 0 15 27 15 28 19 3 29 1 0 73 29) #3=#A(t (30) (common-lisp-user::m-b-c1 ext::location (defun common-lisp-user::m-b-c1) (#2# . 3243) ext::annotate :lambda-list (common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2) common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2 common-lisp-user::x common-lisp-user::production-statement-op #\? eq common-lisp-user::production-statement-target #Y(nil nil nil (24 45 10 26 13 0 19 1 11 12 1 12 17 13 73 39 11 13 0 19 1 14 12 10 3 17 13 29) #3# #2# 3243) common-lisp-user::production-lhs find-if common-lisp-user::query (= common-lisp-user::state common-lisp-user::busy) equalp #Y(nil nil nil (24 45 10 26 13 0 1 19 17 20 29) #3# #2# 3243) common-lisp-user::production-statement-spec common-lisp-user::chunk-spec-slot-spec every #Y(common-lisp-user::m-b-c1 nil nil (24 45 7 24 45 8 24 45 9 26 34 15 12 13 0 19 1 16 12 19 2 17 45 18 34 21 12 13 0 19 1 22 12 19 1 23 12 19 2 24 43 1 29) #3# #2# 3243) si::fset function "Compilation check for queries such that p2 only uses 'state busy' 
  since buffer empty is meaningless for motor style buffers" si::set-documentation)) #2# 3243) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 30 12 19 2 31 15 0 15 32 15 33 19 3 34 1 0 73 29) #4=#A(t (35) (common-lisp-user::m-b-c2 ext::location (defun common-lisp-user::m-b-c2) (#2# . 3809) ext::annotate :lambda-list (common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2) common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2 common-lisp-user::x common-lisp-user::production-statement-op #\? eq common-lisp-user::production-statement-target #Y(nil nil nil (24 45 10 26 13 0 19 1 11 12 1 12 17 13 73 39 11 13 0 19 1 14 12 10 3 17 13 29) #4# #2# 3809) common-lisp-user::production-lhs find-if common-lisp-user::it common-lisp-user::production-statement-spec common-lisp-user::chunk-spec-slot-spec #Y(nil nil nil (24 45 10 26 13 0 19 1 11 12 1 12 17 13 73 39 11 13 0 19 1 14 12 10 3 17 13 29) #4# #2# 3809) common-lisp-user::query2 common-lisp-user::query1 length append :test equal remove-duplicates = #Y(common-lisp-user::m-b-c2 nil nil (24 45 7 24 45 8 24 45 9 26 34 15 12 13 1 19 1 16 12 19 2 17 45 18 10 0 39 12 13 0 19 1 19 12 19 1 20 38 3 75 73 12 43 1 34 21 12 13 0 19 1 16 12 19 2 17 45 18 10 0 39 12 13 0 19 1 19 12 19 1 20 38 3 75 73 12 43 1 46 22 46 23 10 0 16 24 12 10 1 16 24 12 13 0 13 1 19 2 25 12 14 26 15 27 19 3 28 16 24 12 19 3 29 43 2 29) #4# #2# 3809) si::fset function "queries in p1 and p2 must be the same
   NOTE: this doesn't take into account any variables at this time" si::set-documentation)) #2# 3809) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 56 12 19 2 57 1 0 73 29) #5=#A(t (58) (common-lisp-user::motor-reason ext::location (defun common-lisp-user::motor-reason) (#2# . 4760) ext::annotate :lambda-list (common-lisp-user::p1-index common-lisp-user::p2-index common-lisp-user::failed-function) common-lisp-user::p1-index common-lisp-user::p2-index common-lisp-user::failed-function common-lisp-user::m-b-c1 eql "when the first production makes a request the second can only query for state busy." common-lisp-user::m-b-c2 "the queries in both productions must be the same." 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 40 41 42 44 43 45 46 47 56 57 58 60 59 61 62 63 "buffer tests in first production are not allowed." 2 6 18 22 "the buffer is explicitly cleared in the first production." "buffer tests in second production are not allowed." "the buffer is explicitly cleared in the second production." "both productions make requests." #Y(common-lisp-user::motor-reason nil nil (24 45 7 24 45 8 24 45 9 26 13 0 1 10 17 11 39 6 1 12 73 38 257 13 0 1 13 17 11 39 6 1 14 73 38 244 10 2 41 15 94 41 16 91 41 17 88 41 18 85 41 19 82 41 20 79 41 21 76 41 22 73 41 23 70 41 24 67 41 25 64 41 26 61 41 27 58 41 28 55 41 29 52 41 30 49 41 31 46 41 32 43 41 33 40 41 34 37 41 35 34 41 36 31 41 37 28 41 38 25 41 39 22 41 40 19 41 41 16 41 42 13 41 43 10 41 44 7 41 45 4 42 46 6 1 47 73 38 141 41 48 10 41 49 7 41 50 4 42 51 6 1 52 73 38 124 10 1 41 15 94 41 16 91 41 17 88 41 18 85 41 19 82 41 20 79 41 21 76 41 22 73 41 23 70 41 24 67 41 25 64 41 26 61 41 27 58 41 28 55 41 29 52 41 30 49 41 31 46 41 32 43 41 33 40 41 34 37 41 35 34 41 36 31 41 37 28 41 38 25 41 39 22 41 40 19 41 41 16 41 42 13 41 43 10 41 44 7 41 45 4 42 46 6 1 53 73 38 21 41 48 10 41 49 7 41 50 4 42 51 6 1 54 73 38 4 1 55 73 29) #5# #2# 4760) si::fset)) #2# 4760) #Y(si::bytecodes nil nil (15 0 15 1 15 2 77 15 3 77 77 77 15 4 19 9 5 29) #A(t (6) (common-lisp-user::motor ((20 16 common-lisp-user::m-b-c1) (20 0 t) (16 20 common-lisp-user::m-b-c2) (16 16 common-lisp-user::m-b-c2) (16 4 t) (16 0 t) (4 16 common-lisp-user::m-b-c1) (4 0 t) (0 20 t) (0 16 t) (0 4 t)) :default common-lisp-user::compose-motor-buffer common-lisp-user::motor-reason common-lisp-user::define-compilation-type-fct)) #2# 5777))
