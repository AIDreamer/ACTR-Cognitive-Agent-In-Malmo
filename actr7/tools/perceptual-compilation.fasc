(#Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 48 12 19 2 49 1 0 73 29) #1=#A(t (50) (common-lisp-user::compose-perceptual-buffer ext::location (defun common-lisp-user::compose-perceptual-buffer) (#2=#P"C:/Users/Son Pham/Desktop/actr7/tools/perceptual-compilation.lisp" . 0) ext::annotate :lambda-list (common-lisp-user::p1 common-lisp-user::p1-s common-lisp-user::p2 common-lisp-user::p2-s common-lisp-user::buffer) common-lisp-user::p1 common-lisp-user::p1-s common-lisp-user::p2 common-lisp-user::p2-s common-lisp-user::buffer string symbol-name ">" concatenate intern common-lisp-user::bn "=" common-lisp-user::b= "+" common-lisp-user::b+ "?" common-lisp-user::b? :key car find copy-tree common-lisp-user::c1 common-lisp-user::c2 common-lisp-user::q1 common-lisp-user::q2 second common-lisp-user::a1+ common-lisp-user::a2+ common-lisp-user::production-buffer-indices assoc common-lisp-user::it 0 append 4 12 8 16 24 common-lisp-user::buffer-condition-union 20 28 #Y(common-lisp-user::compose-perceptual-buffer nil nil (24 45 7 24 45 8 24 45 9 24 45 10 24 45 11 26 15 12 10 0 16 13 12 15 14 19 3 15 12 19 1 16 45 17 15 12 15 18 10 0 16 13 12 19 3 15 12 19 1 16 45 19 15 12 15 20 10 1 16 13 12 19 3 15 12 19 1 16 45 21 15 12 15 22 10 2 16 13 12 19 3 15 12 19 1 16 45 23 13 2 10 7 4 12 14 24 15 25 19 4 26 16 27 45 28 13 3 10 6 4 12 14 24 15 25 19 4 26 16 27 45 29 13 2 10 9 4 12 14 24 15 25 19 4 26 16 27 45 30 13 3 10 8 4 12 14 24 15 25 19 4 26 16 27 45 31 13 5 10 11 16 32 12 14 24 15 25 19 4 26 16 27 45 33 13 6 10 10 16 32 12 14 24 15 25 19 4 26 16 27 45 34 13 10 13 14 19 1 35 12 19 2 36 5 45 37 10 0 39 5 10 0 38 3 8 0 43 1 42 38 40 10 4 73 39 6 10 4 6 1 73 12 10 2 73 39 6 10 2 6 1 73 12 19 2 39 12 10 0 39 5 10 0 6 1 6 2 73 38 180 41 40 4 42 41 25 10 5 73 39 6 10 5 6 1 73 12 10 1 39 5 10 1 6 1 6 2 73 38 150 42 42 40 10 5 73 39 6 10 5 6 1 73 12 10 2 73 39 6 10 2 6 1 73 12 19 2 39 12 10 0 39 5 10 0 6 1 6 2 73 38 108 41 43 4 42 44 55 13 5 13 4 77 19 3 45 45 37 10 0 39 8 10 0 6 1 73 38 3 75 73 12 43 1 10 3 73 39 6 10 3 6 1 73 12 19 2 39 12 10 0 39 5 10 0 6 1 6 2 73 38 48 41 46 4 42 47 40 10 5 73 39 6 10 5 6 1 73 12 10 3 73 39 6 10 3 6 1 73 12 19 2 39 12 10 1 39 5 10 1 6 1 6 2 73 38 3 75 73 43 10 29) #1# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 26 12 19 2 27 15 0 15 28 15 29 19 3 30 1 0 73 29) #3=#A(t (31) (common-lisp-user::p-b-c1 ext::location (defun common-lisp-user::p-b-c1) (#2# . 4289) ext::annotate :lambda-list (common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2) common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2 common-lisp-user::x common-lisp-user::production-statement-op #\? eq common-lisp-user::production-statement-target #Y(nil nil nil (24 45 10 26 13 0 19 1 11 12 1 12 17 13 73 39 11 13 0 19 1 14 12 10 3 17 13 29) #3# #2# 4289) common-lisp-user::production-lhs find-if common-lisp-user::query (= common-lisp-user::state common-lisp-user::busy) equalp (= common-lisp-user::buffer common-lisp-user::empty) #Y(nil nil nil (24 45 10 26 13 0 1 19 17 20 73 40 7 13 0 1 21 17 20 29) #3# #2# 4289) common-lisp-user::production-statement-spec common-lisp-user::chunk-spec-slot-spec every #Y(common-lisp-user::p-b-c1 nil nil (24 45 7 24 45 8 24 45 9 26 34 15 12 13 0 19 1 16 12 19 2 17 45 18 34 22 12 13 0 19 1 23 12 19 1 24 12 19 2 25 43 1 29) #3# #2# 4289) si::fset function "Compilation check for queries such that p2 only uses 'buffer empty' or
   'state busy'" si::set-documentation)) #2# 4289) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 30 12 19 2 31 15 0 15 32 15 33 19 3 34 1 0 73 29) #4=#A(t (35) (common-lisp-user::p-b-c2 ext::location (defun common-lisp-user::p-b-c2) (#2# . 4880) ext::annotate :lambda-list (common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2) common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2 common-lisp-user::x common-lisp-user::production-statement-op #\? eq common-lisp-user::production-statement-target #Y(nil nil nil (24 45 10 26 13 0 19 1 11 12 1 12 17 13 73 39 11 13 0 19 1 14 12 10 3 17 13 29) #4# #2# 4880) common-lisp-user::production-lhs find-if common-lisp-user::it common-lisp-user::production-statement-spec common-lisp-user::chunk-spec-slot-spec #Y(nil nil nil (24 45 10 26 13 0 19 1 11 12 1 12 17 13 73 39 11 13 0 19 1 14 12 10 3 17 13 29) #4# #2# 4880) common-lisp-user::query2 common-lisp-user::query1 length append :test equal remove-duplicates = #Y(common-lisp-user::p-b-c2 nil nil (24 45 7 24 45 8 24 45 9 26 34 15 12 13 1 19 1 16 12 19 2 17 45 18 10 0 39 12 13 0 19 1 19 12 19 1 20 38 3 75 73 12 43 1 34 21 12 13 0 19 1 16 12 19 2 17 45 18 10 0 39 12 13 0 19 1 19 12 19 1 20 38 3 75 73 12 43 1 46 22 46 23 10 0 16 24 12 10 1 16 24 12 13 0 13 1 19 2 25 12 14 26 15 27 19 3 28 16 24 12 19 3 29 43 2 29) #4# #2# 4880) si::fset function "queries in p1 and p2 must be the same
   NOTE: this doesn't take into account any variables at this time" si::set-documentation)) #2# 4880) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 44 12 19 2 45 1 0 73 29) #5=#A(t (46) (common-lisp-user::perceptual-reason ext::location (defun common-lisp-user::perceptual-reason) (#2# . 5833) ext::annotate :lambda-list (common-lisp-user::p1-index common-lisp-user::p2-index common-lisp-user::failed-function) common-lisp-user::p1-index common-lisp-user::p2-index common-lisp-user::failed-function common-lisp-user::p-b-c1 eql "when the first production makes a request and the second does not harvest it the second can only query for state busy or buffer empty." common-lisp-user::p-b-c2 "the queries in both productions must be the same." > "buffer modfication actions in first production are not allowed." "buffer modfication actions in second production are not allowed." 9 11 13 15 25 27 29 "buffer modfication actions in first production are not allowed." 2 6 10 14 18 22 26 30 "the buffer is explicitly cleared in the first production." "the buffer is explicitly cleared in the second production." "buffer modfication actions in second production are not allowed." 4 20 "both productions make a request." 12 28 "the first production makes a request and the second production harvests the chunk." "the second production harvests a chunk which is there because of buffer stuffing or because strict harvesting has been disabled." #Y(common-lisp-user::perceptual-reason nil nil (24 45 7 24 45 8 24 45 9 26 13 0 1 10 17 11 39 6 1 12 73 38 189 13 0 1 13 17 11 39 6 1 14 73 38 176 13 2 9 30 19 2 15 39 6 1 16 73 38 162 13 1 9 30 19 2 15 39 6 1 17 73 38 148 10 2 41 18 19 41 19 16 41 20 13 41 21 10 41 22 7 41 23 4 42 24 6 1 25 73 38 120 41 26 22 41 27 19 41 28 16 41 29 13 41 30 10 41 31 7 41 32 4 42 33 6 1 34 73 38 91 10 1 41 26 22 41 27 19 41 28 16 41 29 13 41 30 10 41 31 7 41 32 4 42 33 6 1 35 73 38 60 41 18 19 41 19 16 41 20 13 41 21 10 41 22 7 41 23 4 42 24 6 1 36 73 38 34 41 37 4 42 38 6 1 39 73 38 23 10 2 41 37 10 41 40 7 41 38 4 42 41 6 1 42 73 38 4 1 43 73 29) #5# #2# 5833) si::fset)) #2# 5833) #Y(si::bytecodes nil nil (15 0 15 1 15 2 77 15 3 77 77 77 15 4 19 9 5 29) #A(t (6) (common-lisp-user::perceptual ((28 16 common-lisp-user::p-b-c1) (28 0 t) (24 20 common-lisp-user::p-b-c2) (24 16 common-lisp-user::p-b-c2) (24 4 t) (24 0 t) (20 16 common-lisp-user::p-b-c1) (20 0 t) (16 28 common-lisp-user::p-b-c2) (16 24 common-lisp-user::p-b-c2) (16 20 common-lisp-user::p-b-c2) (16 16 common-lisp-user::p-b-c2) (16 12 t) (16 8 t) (16 4 t) (16 0 t) (12 16 common-lisp-user::p-b-c1) (12 0 t) (8 20 t) (8 16 t) (8 4 t) (8 0 t) (4 16 common-lisp-user::p-b-c1) (4 0 t) (0 28 t) (0 24 t) (0 20 t) (0 16 t) (0 12 t) (0 8 t) (0 4 t)) (common-lisp-user::visual-location common-lisp-user::visual common-lisp-user::aural-location common-lisp-user::aural common-lisp-user::temporal) common-lisp-user::compose-perceptual-buffer common-lisp-user::perceptual-reason common-lisp-user::define-compilation-type-fct)) #2# 7383))
