(#Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 50 12 19 2 51 15 0 15 52 15 53 19 3 54 1 0 73 29) #1=#A(t (55) (common-lisp-user::map-retrieval-buffer ext::location (defun common-lisp-user::map-retrieval-buffer) (#2=#P"C:/Users/Son Pham/Desktop/actr7/tools/retrieval-compilation.lisp" . 0) ext::annotate :lambda-list (common-lisp-user::module common-lisp-user::p1 common-lisp-user::p1-s common-lisp-user::p2 common-lisp-user::p2-s common-lisp-user::buffer) common-lisp-user::module common-lisp-user::p1 common-lisp-user::p1-s common-lisp-user::p2 common-lisp-user::p2-s common-lisp-user::buffer common-lisp-user::production-buffer-indices assoc common-lisp-user::p2-style common-lisp-user::p1-style (4 12 20 28) find (8 12 24 28) string "=" symbol-name concatenate intern common-lisp-user::buffer-variable common-lisp-user::production-bindings common-lisp-user::the-chunk common-lisp-user::production-name common-lisp-user::production-drop-out-buffers-map :key car common-lisp-user::mappings "+" ">" second si::%dolist-var condition common-lisp-user::spec-slot-name common-lisp-user::chunk-spec-variable-p common-lisp-user::compilation-module-previous common-lisp-user::previous-production-bindings common-lisp-user::spec-slot-op = eq common-lisp-user::spec-slot-value "=" ">" common-lisp-user::production-compilation-instan common-lisp-user::chunk-slot-value-fct #Y(common-lisp-user::map-retrieval-buffer nil nil (24 45 7 24 45 8 24 45 9 24 45 10 24 45 11 24 45 12 26 13 0 13 4 19 1 13 12 19 2 14 5 12 13 0 13 2 19 1 13 12 19 2 14 5 12 46 15 46 16 13 0 15 17 19 2 18 39 8 13 1 15 19 19 2 18 39 427 15 20 15 21 10 2 16 22 12 19 3 23 12 19 1 24 45 25 13 0 13 5 19 1 26 12 19 2 14 5 45 27 10 0 73 39 386 13 1 13 6 19 1 28 12 19 1 29 12 14 30 15 31 19 4 18 39 29 13 1 13 6 19 1 28 12 19 1 29 12 14 30 15 31 19 4 18 5 12 10 0 3 6 1 38 8 13 1 10 0 3 6 1 45 32 15 20 15 33 10 5 16 22 12 15 34 19 4 23 12 19 1 24 12 10 8 16 35 12 14 30 15 31 19 4 18 16 35 45 36 75 45 37 38 95 10 1 4 51 0 13 0 19 1 38 12 19 1 39 39 26 13 0 19 1 38 12 13 12 19 1 40 12 19 1 41 12 19 2 14 12 10 2 3 51 2 13 0 19 1 42 12 1 43 17 44 39 10 13 0 19 1 45 12 19 1 39 39 26 13 0 19 1 45 12 13 12 19 1 40 12 19 1 41 12 19 2 14 12 10 2 3 51 2 10 1 5 51 1 10 1 40 -97 43 2 15 20 15 46 10 5 16 22 12 15 47 19 4 23 12 19 1 24 12 10 6 4 12 14 30 15 31 19 4 18 16 35 45 36 75 45 37 38 138 10 1 4 51 0 13 0 19 1 38 12 19 1 39 39 26 13 0 19 1 38 12 13 9 19 1 28 12 19 1 48 12 19 2 14 12 10 2 3 51 2 13 0 19 1 42 12 1 43 17 44 39 10 13 0 19 1 45 12 19 1 39 39 69 13 0 19 1 38 12 19 1 39 39 34 13 0 19 1 45 12 13 3 13 0 19 1 38 12 13 2 19 2 14 5 12 19 2 49 3 12 10 2 3 51 2 38 25 13 0 19 1 45 12 13 3 13 0 19 1 38 12 19 2 49 3 12 10 2 3 51 2 10 1 5 51 1 10 1 40 -140 43 2 10 0 73 43 1 43 2 38 3 75 73 43 2 29) #1# #2# 0) si::fset function "map references from p1 to p2 for retrieval style buffer" si::set-documentation)) #2# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 49 12 19 2 50 1 0 73 29) #3=#A(t (51) (common-lisp-user::compose-retrieval-buffer ext::location (defun common-lisp-user::compose-retrieval-buffer) (#2# . 5504) ext::annotate :lambda-list (common-lisp-user::p1 common-lisp-user::p1-s common-lisp-user::p2 common-lisp-user::p2-s common-lisp-user::buffer) common-lisp-user::p1 common-lisp-user::p1-s common-lisp-user::p2 common-lisp-user::p2-s common-lisp-user::buffer string symbol-name ">" concatenate intern common-lisp-user::bn "=" common-lisp-user::b= "+" common-lisp-user::b+ "?" common-lisp-user::b? :key car find copy-tree common-lisp-user::c1 common-lisp-user::c2 common-lisp-user::q1 common-lisp-user::q2 second common-lisp-user::a1+ common-lisp-user::a2+ common-lisp-user::production-buffer-indices assoc common-lisp-user::it 0 append 4 12 (0 2 4 6 16 18 20 22) 8 16 20 24 28 (0 2 4 6 16 18 20 22) #Y(common-lisp-user::compose-retrieval-buffer nil nil (24 45 7 24 45 8 24 45 9 24 45 10 24 45 11 26 15 12 10 0 16 13 12 15 14 19 3 15 12 19 1 16 45 17 15 12 15 18 10 0 16 13 12 19 3 15 12 19 1 16 45 19 15 12 15 20 10 1 16 13 12 19 3 15 12 19 1 16 45 21 15 12 15 22 10 2 16 13 12 19 3 15 12 19 1 16 45 23 13 2 10 7 4 12 14 24 15 25 19 4 26 16 27 45 28 13 3 10 6 4 12 14 24 15 25 19 4 26 16 27 45 29 13 2 10 9 4 12 14 24 15 25 19 4 26 16 27 45 30 13 3 10 8 4 12 14 24 15 25 19 4 26 16 27 45 31 13 5 10 11 16 32 12 14 24 15 25 19 4 26 16 27 45 33 13 6 10 10 16 32 12 14 24 15 25 19 4 26 16 27 45 34 13 10 13 14 19 1 35 12 19 2 36 5 45 37 10 0 39 5 10 0 38 3 8 0 43 1 42 38 40 10 4 73 39 6 10 4 6 1 73 12 10 2 73 39 6 10 2 6 1 73 12 19 2 39 12 10 0 39 5 10 0 6 1 6 2 73 38 300 41 40 4 42 41 85 13 10 13 12 19 1 35 12 19 2 36 5 45 37 10 0 39 6 10 0 73 38 4 8 0 73 12 43 1 15 42 19 2 26 39 25 10 5 73 39 6 10 5 6 1 73 12 10 1 39 5 10 1 6 1 6 2 73 38 23 10 5 73 39 6 10 5 6 1 73 12 10 0 39 5 10 0 6 1 6 2 73 38 210 42 43 40 10 5 73 39 6 10 5 6 1 73 12 10 2 73 39 6 10 2 6 1 73 12 19 2 39 12 10 0 39 5 10 0 6 1 6 2 73 38 168 42 44 40 10 4 73 39 6 10 4 6 1 73 12 10 3 73 39 6 10 3 6 1 73 12 19 2 39 12 10 0 39 5 10 0 6 1 6 2 73 38 126 41 45 7 41 46 4 42 47 115 13 10 13 12 19 1 35 12 19 2 36 5 45 37 10 0 39 6 10 0 73 38 4 8 0 73 12 43 1 15 48 19 2 26 39 40 10 5 73 39 6 10 5 6 1 73 12 10 3 73 39 6 10 3 6 1 73 12 19 2 39 12 10 1 39 5 10 1 6 1 6 2 73 38 38 10 5 73 39 6 10 5 6 1 73 12 10 3 73 39 6 10 3 6 1 73 12 19 2 39 12 10 0 39 5 10 0 6 1 6 2 73 38 3 75 73 43 10 29) #3# #2# 5504) si::fset)) #2# 5504) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 26 12 19 2 27 15 0 15 28 15 29 19 3 30 1 0 73 29) #4=#A(t (31) (common-lisp-user::r-b-c1 ext::location (defun common-lisp-user::r-b-c1) (#2# . 8727) ext::annotate :lambda-list (common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2) common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2 common-lisp-user::x common-lisp-user::production-statement-op #\? eq common-lisp-user::production-statement-target #Y(nil nil nil (24 45 10 26 13 0 19 1 11 12 1 12 17 13 73 39 11 13 0 19 1 14 12 10 3 17 13 29) #4# #2# 8727) common-lisp-user::production-lhs find-if common-lisp-user::query (= common-lisp-user::state common-lisp-user::busy) equalp (= common-lisp-user::buffer common-lisp-user::empty) #Y(nil nil nil (24 45 10 26 13 0 1 19 17 20 73 40 7 13 0 1 21 17 20 29) #4# #2# 8727) common-lisp-user::production-statement-spec common-lisp-user::chunk-spec-slot-spec every #Y(common-lisp-user::r-b-c1 nil nil (24 45 7 24 45 8 24 45 9 26 34 15 12 13 0 19 1 16 12 19 2 17 45 18 34 22 12 13 0 19 1 23 12 19 1 24 12 19 2 25 43 1 29) #4# #2# 8727) si::fset function "Compilation check for queries such that p2 only uses 'buffer empty' or
   'state busy'" si::set-documentation)) #2# 8727) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 30 12 19 2 31 15 0 15 32 15 33 19 3 34 1 0 73 29) #5=#A(t (35) (common-lisp-user::r-b-c2 ext::location (defun common-lisp-user::r-b-c2) (#2# . 9318) ext::annotate :lambda-list (common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2) common-lisp-user::buffer common-lisp-user::p1 common-lisp-user::p2 common-lisp-user::x common-lisp-user::production-statement-op #\? eq common-lisp-user::production-statement-target #Y(nil nil nil (24 45 10 26 13 0 19 1 11 12 1 12 17 13 73 39 11 13 0 19 1 14 12 10 3 17 13 29) #5# #2# 9318) common-lisp-user::production-lhs find-if common-lisp-user::it common-lisp-user::production-statement-spec common-lisp-user::chunk-spec-slot-spec #Y(nil nil nil (24 45 10 26 13 0 19 1 11 12 1 12 17 13 73 39 11 13 0 19 1 14 12 10 3 17 13 29) #5# #2# 9318) common-lisp-user::query2 common-lisp-user::query1 length append :test equal remove-duplicates = #Y(common-lisp-user::r-b-c2 nil nil (24 45 7 24 45 8 24 45 9 26 34 15 12 13 1 19 1 16 12 19 2 17 45 18 10 0 39 12 13 0 19 1 19 12 19 1 20 38 3 75 73 12 43 1 34 21 12 13 0 19 1 16 12 19 2 17 45 18 10 0 39 12 13 0 19 1 19 12 19 1 20 38 3 75 73 12 43 1 46 22 46 23 10 0 16 24 12 10 1 16 24 12 13 0 13 1 19 2 25 12 14 26 15 27 19 3 28 16 24 12 19 3 29 43 2 29) #5# #2# 9318) si::fset function "queries in p1 and p2 must be the same
   NOTE: this doesn't take into account any variables at this time" si::set-documentation)) #2# 9318) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 19 4 4 15 0 14 5 77 15 6 19 4 4 15 0 1 38 12 19 2 39 1 0 73 29) #6=#A(t (40) (common-lisp-user::retrieval-reason ext::location (defun common-lisp-user::retrieval-reason) (#2# . 10269) ext::annotate :lambda-list (common-lisp-user::p1-index common-lisp-user::p2-index common-lisp-user::failed-function) common-lisp-user::p1-index common-lisp-user::p2-index common-lisp-user::failed-function common-lisp-user::r-b-c1 eql "when the first production makes a request and the second does not harvest it the second can only query for state busy or buffer empty." common-lisp-user::r-b-c2 "the queries in both productions must be the same." > "buffer modfication actions in first production are not allowed." "buffer modfication actions in second production are not allowed." 9 11 13 15 25 27 29 "buffer modfication actions in first production are not allowed." 2 6 10 14 18 22 26 30 "the buffer is explicitly cleared in the first production." "the buffer is explicitly cleared in the second production." "buffer modfication actions in second production are not allowed." "strict harvesting should have prevented the buffer condition from matching in the second production." #Y(common-lisp-user::retrieval-reason nil nil (24 45 7 24 45 8 24 45 9 26 13 0 1 10 17 11 39 6 1 12 73 38 159 13 0 1 13 17 11 39 6 1 14 73 38 146 13 2 9 30 19 2 15 39 6 1 16 73 38 132 13 1 9 30 19 2 15 39 6 1 17 73 38 118 10 2 41 18 19 41 19 16 41 20 13 41 21 10 41 22 7 41 23 4 42 24 6 1 25 73 38 90 41 26 22 41 27 19 41 28 16 41 29 13 41 30 10 41 31 7 41 32 4 42 33 6 1 34 73 38 61 10 1 41 26 22 41 27 19 41 28 16 41 29 13 41 30 10 41 31 7 41 32 4 42 33 6 1 35 73 38 30 41 18 19 41 19 16 41 20 13 41 21 10 41 22 7 41 23 4 42 24 6 1 36 73 38 4 1 37 73 29) #6# #2# 10269) si::fset)) #2# 10269) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 15 4 77 77 15 5 15 6 19 9 7 29) #A(t (8) (common-lisp-user::retrieval ((28 28 t) (28 24 t) (28 20 common-lisp-user::r-b-c1) (28 16 common-lisp-user::r-b-c1) (28 12 t) (28 8 t) (28 4 t) (28 0 t) (24 20 common-lisp-user::r-b-c2) (24 16 common-lisp-user::r-b-c2) (24 4 t) (24 0 t) (20 28 t) (20 24 t) (20 20 common-lisp-user::r-b-c1) (20 16 common-lisp-user::r-b-c1) (20 12 t) (20 8 t) (20 4 t) (20 0 t) (16 28 common-lisp-user::r-b-c2) (16 24 common-lisp-user::r-b-c2) (16 20 common-lisp-user::r-b-c2) (16 16 common-lisp-user::r-b-c2) (16 12 t) (16 8 t) (16 4 t) (16 0 t) (12 28 t) (12 24 t) (12 20 common-lisp-user::r-b-c1) (12 16 common-lisp-user::r-b-c1) (12 12 t) (12 8 t) (12 4 t) (12 0 t) (8 20 t) (8 16 t) (8 4 t) (8 0 t) (4 28 t) (4 24 t) (4 20 common-lisp-user::r-b-c1) (4 16 common-lisp-user::r-b-c1) (4 12 t) (4 8 t) (4 4 t) (4 0 t) (0 28 t) (0 24 t) (0 20 t) (0 16 t) (0 12 t) (0 8 t) (0 4 t)) (common-lisp-user::retrieval) common-lisp-user::map-retrieval-buffer common-lisp-user::compose-retrieval-buffer t common-lisp-user::retrieval-reason common-lisp-user::define-compilation-type-fct)) #2# 11521))
